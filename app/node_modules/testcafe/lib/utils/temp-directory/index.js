"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const async_exit_hook_1 = __importDefault(require("async-exit-hook"));
const tmp_1 = __importDefault(require("tmp"));
const make_dir_1 = __importDefault(require("make-dir"));
const lockfile_1 = __importDefault(require("./lockfile"));
const cleanup_process_1 = __importDefault(require("./cleanup-process"));
const promisified_functions_1 = require("../../utils/promisified-functions");
// NOTE: mutable for testing purposes
const TESTCAFE_TMP_DIRS_ROOT = path_1.default.join(os_1.default.tmpdir(), 'testcafe');
const DEFAULT_NAME_PREFIX = 'tmp';
const USED_TEMP_DIRS = {};
const DEBUG_LOGGER = (0, debug_1.default)('testcafe:utils:temp-directory');
class TempDirectory {
    constructor(namePrefix) {
        this.namePrefix = namePrefix || DEFAULT_NAME_PREFIX;
        this.path = '';
        this.lockFile = null;
    }
    async _getTmpDirsList() {
        const tmpDirNames = await (0, promisified_functions_1.readDir)(TempDirectory.TEMP_DIRECTORIES_ROOT);
        return tmpDirNames
            .filter(tmpDir => !USED_TEMP_DIRS[tmpDir])
            .filter(tmpDir => path_1.default.basename(tmpDir).startsWith(this.namePrefix));
    }
    async _findFreeTmpDir(tmpDirNames) {
        for (const tmpDirName of tmpDirNames) {
            const tmpDirPath = path_1.default.join(TempDirectory.TEMP_DIRECTORIES_ROOT, tmpDirName);
            const lockFile = new lockfile_1.default(tmpDirPath);
            if (lockFile.init()) {
                this.path = tmpDirPath;
                this.lockFile = lockFile;
                return true;
            }
        }
        return false;
    }
    async _createNewTmpDir() {
        this.path = tmp_1.default.tmpNameSync({ dir: TempDirectory.TEMP_DIRECTORIES_ROOT, prefix: this.namePrefix + '-' });
        await (0, make_dir_1.default)(this.path);
        this.lockFile = new lockfile_1.default(this.path);
        this.lockFile.init();
    }
    _disposeSync() {
        if (!USED_TEMP_DIRS[this.path])
            return;
        this.lockFile.dispose();
        delete USED_TEMP_DIRS[this.path];
    }
    static async createDirectory(prefix) {
        const tmpDir = new TempDirectory(prefix);
        await tmpDir.init();
        return tmpDir;
    }
    static disposeDirectoriesSync() {
        Object.values(USED_TEMP_DIRS).forEach(tmpDir => tmpDir._disposeSync());
    }
    async init() {
        await (0, make_dir_1.default)(TempDirectory.TEMP_DIRECTORIES_ROOT);
        const tmpDirNames = await this._getTmpDirsList(this.namePrefix);
        DEBUG_LOGGER('Found temp directories:', tmpDirNames);
        const existingTmpDirFound = await this._findFreeTmpDir(tmpDirNames);
        if (!existingTmpDirFound)
            await this._createNewTmpDir();
        DEBUG_LOGGER('Temp directory path: ', this.path);
        await cleanup_process_1.default.init();
        await cleanup_process_1.default.addDirectory(this.path);
        USED_TEMP_DIRS[this.path] = this;
    }
    async dispose() {
        if (!USED_TEMP_DIRS[this.path])
            return;
        this.lockFile.dispose();
        await cleanup_process_1.default.removeDirectory(this.path);
        delete USED_TEMP_DIRS[this.path];
    }
}
exports.default = TempDirectory;
// NOTE: exposed for testing purposes
TempDirectory.TEMP_DIRECTORIES_ROOT = TESTCAFE_TMP_DIRS_ROOT;
(0, async_exit_hook_1.default)(TempDirectory.disposeDirectoriesSync);
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbHMvdGVtcC1kaXJlY3RvcnkvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxrREFBMEI7QUFDMUIsNENBQW9CO0FBQ3BCLGdEQUF3QjtBQUN4QixzRUFBNEM7QUFDNUMsOENBQXNCO0FBQ3RCLHdEQUErQjtBQUMvQiwwREFBa0M7QUFDbEMsd0VBQStDO0FBQy9DLDZFQUE0RDtBQUc1RCxxQ0FBcUM7QUFDckMsTUFBTSxzQkFBc0IsR0FBRyxjQUFJLENBQUMsSUFBSSxDQUFDLFlBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxVQUFVLENBQUMsQ0FBQztBQUNsRSxNQUFNLG1CQUFtQixHQUFNLEtBQUssQ0FBQztBQUNyQyxNQUFNLGNBQWMsR0FBVyxFQUFFLENBQUM7QUFDbEMsTUFBTSxZQUFZLEdBQWEsSUFBQSxlQUFLLEVBQUMsK0JBQStCLENBQUMsQ0FBQztBQUV0RSxNQUFxQixhQUFhO0lBQzlCLFlBQWEsVUFBVTtRQUNuQixJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsSUFBSSxtQkFBbUIsQ0FBQztRQUVwRCxJQUFJLENBQUMsSUFBSSxHQUFPLEVBQUUsQ0FBQztRQUNuQixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztJQUN6QixDQUFDO0lBRUQsS0FBSyxDQUFDLGVBQWU7UUFDakIsTUFBTSxXQUFXLEdBQUcsTUFBTSxJQUFBLCtCQUFPLEVBQUMsYUFBYSxDQUFDLHFCQUFxQixDQUFDLENBQUM7UUFFdkUsT0FBTyxXQUFXO2FBQ2IsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDekMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsY0FBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFD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QUFDO1FBRXhCLE1BQU0seUJBQWMsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRWhELE9BQU8sY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNyQyxDQUFDO0NBQ0o7QUE5RkQsZ0NBOEZDO0FBRUQscUNBQXFDO0FBQ3JDLGFBQWEsQ0FBQyxxQkFBcUIsR0FBRyxzQkFBc0IsQ0FBQztBQUU3RCxJQUFBLHlCQUFhLEVBQUMsYUFBYSxDQUFDLHNCQUFzQixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IG9zIGZyb20gJ29zJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHNldHVwRXhpdEhvb2sgZnJvbSAnYXN5bmMtZXhpdC1ob29rJztcbmltcG9ydCB0bXAgZnJvbSAndG1wJztcbmltcG9ydCBtYWtlRGlyIGZyb20gJ21ha2UtZGlyJztcbmltcG9ydCBMb2NrRmlsZSBmcm9tICcuL2xvY2tmaWxlJztcbmltcG9ydCBjbGVhbnVwUHJvY2VzcyBmcm9tICcuL2NsZWFudXAtcHJvY2Vzcyc7XG5pbXBvcnQgeyByZWFkRGlyIH0gZnJvbSAnLi4vLi4vdXRpbHMvcHJvbWlzaWZpZWQtZnVuY3Rpb25zJztcblxuXG4vLyBOT1RFOiBtdXRhYmxlIGZvciB0ZXN0aW5nIHB1cnBvc2VzXG5jb25zdCBURVNUQ0FGRV9UTVBfRElSU19ST09UID0gcGF0aC5qb2luKG9zLnRtcGRpcigpLCAndGVzdGNhZmUnKTtcbmNvbnN0IERFRkFVTFRfTkFNRV9QUkVGSVggICAgPSAndG1wJztcbmNvbnN0IFVTRURfVEVNUF9ESVJTICAgICAgICAgPSB7fTtcbmNvbnN0IERFQlVHX0xPR0dFUiAgICAgICAgICAgPSBkZWJ1ZygndGVzdGNhZmU6dXRpbHM6dGVtcC1kaXJlY3RvcnknKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVtcERpcmVjdG9yeSB7XG4gICAgY29uc3RydWN0b3IgKG5hbWVQcmVmaXgpIHtcbiAgICAgICAgdGhpcy5uYW1lUHJlZml4ID0gbmFtZVByZWZpeCB8fCBERUZBVUxUX05BTUVfUFJFRklYO1xuXG4gICAgICAgIHRoaXMucGF0aCAgICAgPSAnJztcbiAgICAgICAgdGhpcy5sb2NrRmlsZSA9IG51bGw7XG4gICAgfVxuXG4gICAgYXN5bmMgX2dldFRtcERpcnNMaXN0ICgpIHtcbiAgICAgICAgY29uc3QgdG1wRGlyTmFtZXMgPSBhd2FpdCByZWFkRGlyKFRlbXBEaXJlY3RvcnkuVEVNUF9ESVJFQ1RPUklFU19ST09UKTtcblxuICAgICAgICByZXR1cm4gdG1wRGlyTmFtZXNcbiAgICAgICAgICAgIC5maWx0ZXIodG1wRGlyID0+ICFVU0VEX1RFTVBfRElSU1t0bXBEaXJdKVxuICAgICAgICAgICAgLmZpbHRlcih0bXBEaXIgPT4gcGF0aC5iYXNlbmFtZSh0bXBEaXIpLnN0YXJ0c1dpdGgodGhpcy5uYW1lUHJlZml4KSk7XG4gICAgfVxuXG4gICAgYXN5bmMgX2ZpbmRGcmVlVG1wRGlyICh0bXBEaXJOYW1lcykge1xuICAgICAgICBmb3IgKGNvbnN0IHRtcERpck5hbWUgb2YgdG1wRGlyTmFtZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcERpclBhdGggPSBwYXRoLmpvaW4oVGVtcERpcmVjdG9yeS5URU1QX0RJUkVDVE9SSUVTX1JPT1QsIHRtcERpck5hbWUpO1xuXG4gICAgICAgICAgICBjb25zdCBsb2NrRmlsZSA9IG5ldyBMb2NrRmlsZSh0bXBEaXJQYXRoKTtcblxuICAgICAgICAgICAgaWYgKGxvY2tGaWxlLmluaXQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aCAgICAgPSB0bXBEaXJQYXRoO1xuICAgICAgICAgICAgICAgIHRoaXMubG9ja0ZpbGUgPSBsb2NrRmlsZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGFzeW5jIF9jcmVhdGVOZXdUbXBEaXIgKCkge1xuICAgICAgICB0aGlzLnBhdGggPSB0bXAudG1wTmFtZVN5bmMoeyBkaXI6IFRlbXBEaXJlY3RvcnkuVEVNUF9ESVJFQ1RPUklFU19ST09ULCBwcmVmaXg6IHRoaXMubmFtZVByZWZpeCArICctJyB9KTtcblxuICAgICAgICBhd2FpdCBtYWtlRGlyKHRoaXMucGF0aCk7XG5cbiAgICAgICAgdGhpcy5sb2NrRmlsZSA9IG5ldyBMb2NrRmlsZSh0aGlzLnBhdGgpO1xuXG4gICAgICAgIHRoaXMubG9ja0ZpbGUuaW5pdCgpO1xuICAgIH1cblxuICAgIF9kaXNwb3NlU3luYyAoKSB7XG4gICAgICAgIGlmICghVVNFRF9URU1QX0RJUlNbdGhpcy5wYXRoXSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB0aGlzLmxvY2tGaWxlLmRpc3Bvc2UoKTtcblxuICAgICAgICBkZWxldGUgVVNFRF9URU1QX0RJUlNbdGhpcy5wYXRoXTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlRGlyZWN0b3J5IChwcmVmaXgpIHtcbiAgICAgICAgY29uc3QgdG1wRGlyID0gbmV3IFRlbXBEaXJlY3RvcnkocHJlZml4KTtcblxuICAgICAgICBhd2FpdCB0bXBEaXIuaW5pdCgpO1xuXG4gICAgICAgIHJldHVybiB0bXBEaXI7XG4gICAgfVxuXG4gICAgc3RhdGljIGRpc3Bvc2VEaXJlY3Rvcmllc1N5bmMgKCkge1xuICAgICAgICBPYmplY3QudmFsdWVzKFVTRURfVEVNUF9ESVJTKS5mb3JFYWNoKHRtcERpciA9PiB0bXBEaXIuX2Rpc3Bvc2VTeW5jKCkpO1xuICAgIH1cblxuICAgIGFzeW5jIGluaXQgKCkge1xuICAgICAgICBhd2FpdCBtYWtlRGlyKFRlbXBEaXJlY3RvcnkuVEVNUF9ESVJFQ1RPUklFU19ST09UKTtcblxuICAgICAgICBjb25zdCB0bXBEaXJOYW1lcyA9IGF3YWl0IHRoaXMuX2dldFRtcERpcnNMaXN0KHRoaXMubmFtZVByZWZpeCk7XG5cbiAgICAgICAgREVCVUdfTE9HR0VSKCdGb3VuZCB0ZW1wIGRpcmVjdG9yaWVzOicsIHRtcERpck5hbWVzKTtcblxuICAgICAgICBjb25zdCBleGlzdGluZ1RtcERpckZvdW5kID0gYXdhaXQgdGhpcy5fZmluZEZyZWVUbXBEaXIodG1wRGlyTmFtZXMpO1xuXG4gICAgICAgIGlmICghZXhpc3RpbmdUbXBEaXJGb3VuZClcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NyZWF0ZU5ld1RtcERpcigpO1xuXG4gICAgICAgIERFQlVHX0xPR0dFUignVGVtcCBkaXJlY3RvcnkgcGF0aDogJywgdGhpcy5wYXRoKTtcblxuICAgICAgICBhd2FpdCBjbGVhbnVwUHJvY2Vzcy5pbml0KCk7XG4gICAgICAgIGF3YWl0IGNsZWFudXBQcm9jZXNzLmFkZERpcmVjdG9yeSh0aGlzLnBhdGgpO1xuXG4gICAgICAgIFVTRURfVEVNUF9ESVJTW3RoaXMucGF0aF0gPSB0aGlzO1xuICAgIH1cblxuICAgIGFzeW5jIGRpc3Bvc2UgKCkge1xuICAgICAgICBpZiAoIVVTRURfVEVNUF9ESVJTW3RoaXMucGF0aF0pXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdGhpcy5sb2NrRmlsZS5kaXNwb3NlKCk7XG5cbiAgICAgICAgYXdhaXQgY2xlYW51cFByb2Nlc3MucmVtb3ZlRGlyZWN0b3J5KHRoaXMucGF0aCk7XG5cbiAgICAgICAgZGVsZXRlIFVTRURfVEVNUF9ESVJTW3RoaXMucGF0aF07XG4gICAgfVxufVxuXG4vLyBOT1RFOiBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzXG5UZW1wRGlyZWN0b3J5LlRFTVBfRElSRUNUT1JJRVNfUk9PVCA9IFRFU1RDQUZFX1RNUF9ESVJTX1JPT1Q7XG5cbnNldHVwRXhpdEhvb2soVGVtcERpcmVjdG9yeS5kaXNwb3NlRGlyZWN0b3JpZXNTeW5jKTtcbiJdfQ==