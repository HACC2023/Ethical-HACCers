"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkIsVM = void 0;
const os_1 = __importDefault(require("os"));
const promisified_functions_1 = require("./promisified-functions");
const PLATFORM = {
    WIN: 'win32',
    LINUX: 'linux',
    MAC: 'darwin',
};
const VM_REGEX = /virtual|vmware|hyperv|wsl|hyper-v|microsoft|parallels|qemu/gi;
const NOT_FOUND_REGEX_LINUX = /systemd-detect-virt: not found/ig;
const VM_BIOS = '0';
const COMMANDS = {
    WINDOWS_BIOS_NUMBER: 'WMIC BIOS GET SERIALNUMBER',
    WINDOWS_MODEL: 'WMIC COMPUTERSYSTEM GET MODEL',
    WINDOWS_MANUFACTURER: 'WMIC COMPUTERSYSTEM GET MANUFACTURER',
    LINUX_DETECT_VM: 'systemd-detect-virt',
    MAC_MANUFACTURER: 'ioreg -l | grep -e Manufacturer -e \'Vendor Name\'',
};
async function getCommandOutput(command) {
    const { stdout } = await (0, promisified_functions_1.exec)(command);
    return stdout;
}
async function isLinuxVM() {
    let isVM = false;
    try {
        await (0, promisified_functions_1.exec)(COMMANDS.LINUX_DETECT_VM);
        isVM = true;
    }
    catch (error) {
        isVM = NOT_FOUND_REGEX_LINUX.test(error.stderr);
    }
    return isVM;
}
async function isWinVM() {
    const biosNumberOutput = await getCommandOutput(COMMANDS.WINDOWS_BIOS_NUMBER);
    const modelOutput = await getCommandOutput(COMMANDS.WINDOWS_MODEL);
    const manufacturerOutput = await getCommandOutput(COMMANDS.WINDOWS_MANUFACTURER);
    return biosNumberOutput === VM_BIOS || VM_REGEX.test(modelOutput) || VM_REGEX.test(manufacturerOutput);
}
async function isMacVM() {
    return VM_REGEX.test(await getCommandOutput(COMMANDS.MAC_MANUFACTURER));
}
async function checkIsVM() {
    switch (os_1.default.platform()) {
        case PLATFORM.LINUX: return await isLinuxVM();
        case PLATFORM.WIN: return await isWinVM();
        case PLATFORM.MAC: return await isMacVM();
        default:
            return false;
    }
}
exports.checkIsVM = checkIsVM;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2staXMtdm0uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbHMvY2hlY2staXMtdm0udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsNENBQW9CO0FBQ3BCLG1FQUErQztBQUUvQyxNQUFNLFFBQVEsR0FBRztJQUNiLEdBQUcsRUFBSSxPQUFPO0lBQ2QsS0FBSyxFQUFFLE9BQU87SUFDZCxHQUFHLEVBQUksUUFBUTtDQUNsQixDQUFDO0FBRUYsTUFBTSxRQUFRLEdBQWdCLDhEQUE4RCxDQUFDO0FBQzdGLE1BQU0scUJBQXFCLEdBQUcsa0NBQWtDLENBQUM7QUFFakUsTUFBTSxPQUFPLEdBQUksR0FBRyxDQUFDO0FBQ3JCLE1BQU0sUUFBUSxHQUFHO0lBQ2IsbUJBQW1CLEVBQUcsNEJBQTRCO0lBQ2xELGFBQWEsRUFBUywrQkFBK0I7SUFDckQsb0JBQW9CLEVBQUUsc0NBQXNDO0lBQzVELGVBQWUsRUFBTyxxQkFBcUI7SUFDM0MsZ0JBQWdCLEVBQU0sb0RBQW9EO0NBQzdFLENBQUM7QUFFRixLQUFLLFVBQVUsZ0JBQWdCLENBQUUsT0FBZTtJQUM1QyxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsTUFBTSxJQUFBLDRCQUFJLEVBQUMsT0FBTyxDQUFDLENBQUM7SUFFdkMsT0FBTyxNQUFNLENBQUM7QUFDbEIsQ0FBQztBQUVELEtBQUssVUFBVSxTQUFTO0lBQ3BCLElBQUksSUFBSSxHQUFHLEtBQUssQ0FBQztJQUVqQixJQUFJO1FBQ0EsTUFBTSxJQUFBLDRCQUFJLEVBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBRXJDLElBQUksR0FBRyxJQUFJLENBQUM7S0FDZjtJQUNELE9BQU8sS0FBVSxFQUFFO1FBQ2YsSUFBSSxHQUFHLHFCQUFxQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDbkQ7SUFFRCxPQUFPLElBQUksQ0FBQztBQUNoQixDQUFDO0FBRUQsS0FBSyxVQUFVLE9BQU87SUFDbEIsTUFBTSxnQkFBZ0IsR0FBSyxNQUFNLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0lBQ2hGLE1BQU0sV0FBVyxHQUFVLE1BQU0sZ0JBQWdCLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQzFFLE1BQU0sa0JBQWtCLEdBQUcsTUFBTSxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsb0JBQW9CLENBQUMsQ0FBQztJQUVqRixPQUFPLGdCQUFnQixLQUFLLE9BQU8sSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUMzRyxDQUFDO0FBRUQsS0FBSyxVQUFVLE9BQU87SUFDbEIsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sZ0JBQWdCLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQztBQUM1RSxDQUFDO0FBRU0sS0FBSyxVQUFVLFNBQVM7SUFDM0IsUUFBUSxZQUFFLENBQUMsUUFBUSxFQUFFLEVBQUU7UUFDbkIsS0FBSyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxNQUFNLFNBQVMsRUFBRSxDQUFDO1FBQzlDLEtBQUssUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sTUFBTSxPQUFPLEVBQUUsQ0FBQztRQUMxQyxLQUFLLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLE1BQU0sT0FBTyxFQUFFLENBQUM7UUFDMUM7WUFDSSxPQUFPLEtBQUssQ0FBQztLQUNwQjtBQUNMLENBQUM7QUFSRCw4QkFRQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBvcyBmcm9tICdvcyc7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAnLi9wcm9taXNpZmllZC1mdW5jdGlvbnMnO1xuXG5jb25zdCBQTEFURk9STSA9IHtcbiAgICBXSU46ICAgJ3dpbjMyJyxcbiAgICBMSU5VWDogJ2xpbnV4JyxcbiAgICBNQUM6ICAgJ2RhcndpbicsXG59O1xuXG5jb25zdCBWTV9SRUdFWCAgICAgICAgICAgICAgPSAvdmlydHVhbHx2bXdhcmV8aHlwZXJ2fHdzbHxoeXBlci12fG1pY3Jvc29mdHxwYXJhbGxlbHN8cWVtdS9naTtcbmNvbnN0IE5PVF9GT1VORF9SRUdFWF9MSU5VWCA9IC9zeXN0ZW1kLWRldGVjdC12aXJ0OiBub3QgZm91bmQvaWc7XG5cbmNvbnN0IFZNX0JJT1MgID0gJzAnO1xuY29uc3QgQ09NTUFORFMgPSB7XG4gICAgV0lORE9XU19CSU9TX05VTUJFUjogICdXTUlDIEJJT1MgR0VUIFNFUklBTE5VTUJFUicsXG4gICAgV0lORE9XU19NT0RFTDogICAgICAgICdXTUlDIENPTVBVVEVSU1lTVEVNIEdFVCBNT0RFTCcsXG4gICAgV0lORE9XU19NQU5VRkFDVFVSRVI6ICdXTUlDIENPTVBVVEVSU1lTVEVNIEdFVCBNQU5VRkFDVFVSRVInLFxuICAgIExJTlVYX0RFVEVDVF9WTTogICAgICAnc3lzdGVtZC1kZXRlY3QtdmlydCcsXG4gICAgTUFDX01BTlVGQUNUVVJFUjogICAgICdpb3JlZyAtbCB8IGdyZXAgLWUgTWFudWZhY3R1cmVyIC1lIFxcJ1ZlbmRvciBOYW1lXFwnJyxcbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGdldENvbW1hbmRPdXRwdXQgKGNvbW1hbmQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgeyBzdGRvdXQgfSA9IGF3YWl0IGV4ZWMoY29tbWFuZCk7XG5cbiAgICByZXR1cm4gc3Rkb3V0O1xufVxuXG5hc3luYyBmdW5jdGlvbiBpc0xpbnV4Vk0gKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGxldCBpc1ZNID0gZmFsc2U7XG5cbiAgICB0cnkge1xuICAgICAgICBhd2FpdCBleGVjKENPTU1BTkRTLkxJTlVYX0RFVEVDVF9WTSk7XG5cbiAgICAgICAgaXNWTSA9IHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgIGlzVk0gPSBOT1RfRk9VTkRfUkVHRVhfTElOVVgudGVzdChlcnJvci5zdGRlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBpc1ZNO1xufVxuXG5hc3luYyBmdW5jdGlvbiBpc1dpblZNICgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBiaW9zTnVtYmVyT3V0cHV0ICAgPSBhd2FpdCBnZXRDb21tYW5kT3V0cHV0KENPTU1BTkRTLldJTkRPV1NfQklPU19OVU1CRVIpO1xuICAgIGNvbnN0IG1vZGVsT3V0cHV0ICAgICAgICA9IGF3YWl0IGdldENvbW1hbmRPdXRwdXQoQ09NTUFORFMuV0lORE9XU19NT0RFTCk7XG4gICAgY29uc3QgbWFudWZhY3R1cmVyT3V0cHV0ID0gYXdhaXQgZ2V0Q29tbWFuZE91dHB1dChDT01NQU5EUy5XSU5ET1dTX01BTlVGQUNUVVJFUik7XG5cbiAgICByZXR1cm4gYmlvc051bWJlck91dHB1dCA9PT0gVk1fQklPUyB8fCBWTV9SRUdFWC50ZXN0KG1vZGVsT3V0cHV0KSB8fCBWTV9SRUdFWC50ZXN0KG1hbnVmYWN0dXJlck91dHB1dCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGlzTWFjVk0gKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiBWTV9SRUdFWC50ZXN0KGF3YWl0IGdldENvbW1hbmRPdXRwdXQoQ09NTUFORFMuTUFDX01BTlVGQUNUVVJFUikpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tJc1ZNICgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBzd2l0Y2ggKG9zLnBsYXRmb3JtKCkpIHtcbiAgICAgICAgY2FzZSBQTEFURk9STS5MSU5VWDogcmV0dXJuIGF3YWl0IGlzTGludXhWTSgpO1xuICAgICAgICBjYXNlIFBMQVRGT1JNLldJTjogcmV0dXJuIGF3YWl0IGlzV2luVk0oKTtcbiAgICAgICAgY2FzZSBQTEFURk9STS5NQUM6IHJldHVybiBhd2FpdCBpc01hY1ZNKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIl19