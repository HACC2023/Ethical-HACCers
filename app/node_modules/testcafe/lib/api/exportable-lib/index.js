"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lazyRequire = require('import-lazy')(require);
const ClientFunctionBuilder = lazyRequire('../../client-functions/client-function-builder');
const SelectorBuilder = lazyRequire('../../client-functions/selectors/selector-builder');
const role = lazyRequire('../../role');
const createRequestLogger = lazyRequire('../request-hooks/request-logger');
const createRequestMock = lazyRequire('../request-hooks/request-mock/create-request-mock');
const userVariables = lazyRequire('../user-variables');
const getTestCafeVersion = lazyRequire('../../utils/get-testcafe-version');
// NOTE: We can't use lazy require for RequestHook, because it will break base class detection for inherited classes
let RequestHook = null;
// NOTE: We can't use lazy require for testControllerProxy, because it will break test controller detection
let testControllerProxy = null;
function Role(loginUrl, initFn, options) {
    return role.createRole(loginUrl, initFn, options);
}
function RequestMock() {
    return createRequestMock();
}
function RequestLogger(requestFilterRuleInit, logOptions) {
    return createRequestLogger(requestFilterRuleInit, logOptions);
}
function ClientFunction(fn, options) {
    const builder = new ClientFunctionBuilder(fn, options, { instantiation: 'ClientFunction' });
    return builder.getFunction();
}
function Selector(fn, options) {
    const builder = new SelectorBuilder(fn, options, { instantiation: 'Selector' });
    return builder.getFunction();
}
Object.defineProperty(Role, 'anonymous', {
    get: () => role.createAnonymousRole,
});
const exportableLib = {
    Role,
    ClientFunction,
    Selector,
    RequestLogger,
    RequestMock,
    get RequestHook() {
        if (!RequestHook)
            RequestHook = require('../request-hooks/hook');
        return RequestHook;
    },
    get t() {
        if (!testControllerProxy)
            testControllerProxy = require('../test-controller/proxy');
        return testControllerProxy;
    },
    get userVariables() {
        return userVariables.value;
    },
    get version() {
        return getTestCafeVersion();
    },
};
exports.default = exportableLib;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvYXBpL2V4cG9ydGFibGUtbGliL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsTUFBTSxXQUFXLEdBQWEsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzlELE1BQU0scUJBQXFCLEdBQUcsV0FBVyxDQUFDLGdEQUFnRCxDQUFDLENBQUM7QUFDNUYsTUFBTSxlQUFlLEdBQVMsV0FBVyxDQUFDLG1EQUFtRCxDQUFDLENBQUM7QUFDL0YsTUFBTSxJQUFJLEdBQW9CLFdBQVcsQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUN4RCxNQUFNLG1CQUFtQixHQUFLLFdBQVcsQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO0FBQzdFLE1BQU0saUJBQWlCLEdBQU8sV0FBVyxDQUFDLG1EQUFtRCxDQUFDLENBQUM7QUFDL0YsTUFBTSxhQUFhLEdBQVcsV0FBVyxDQUFDLG1CQUFtQixDQUFDLENBQUM7QUFDL0QsTUFBTSxrQkFBa0IsR0FBTSxXQUFXLENBQUMsa0NBQWtDLENBQUMsQ0FBQztBQUU5RSxvSEFBb0g7QUFDcEgsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDO0FBRXZCLDJHQUEyRztBQUMzRyxJQUFJLG1CQUFtQixHQUFHLElBQUksQ0FBQztBQUUvQixTQUFTLElBQUksQ0FBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLE9BQU87SUFDcEMsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDdEQsQ0FBQztBQUVELFNBQVMsV0FBVztJQUNoQixPQUFPLGlCQUFpQixFQUFFLENBQUM7QUFDL0IsQ0FBQztBQUVELFNBQVMsYUFBYSxDQUFFLHFCQUFxQixFQUFFLFVBQVU7SUFDckQsT0FBTyxtQkFBbUIsQ0FBQyxxQkFBcUIsRUFBRSxVQUFVLENBQUMsQ0FBQztBQUNsRSxDQUFDO0FBRUQsU0FBUyxjQUFjLENBQUUsRUFBRSxFQUFFLE9BQU87SUFDaEMsTUFBTSxPQUFPLEdBQUcsSUFBSSxxQkFBcUIsQ0FBQyxFQUFFLEVBQUUsT0FBTyxFQUFFLEVBQUUsYUFBYSxFQUFFLGdCQUFnQixFQUFFLENBQUMsQ0FBQztJQUU1RixPQUFPLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQztBQUNqQyxDQUFDO0FBRUQsU0FBUyxRQUFRLENBQUUsRUFBRSxFQUFFLE9BQU87SUFDMUIsTUFBTSxPQUFPLEdBQUcsSUFBSSxlQUFlLENBQUMsRUFBRSxFQUFFLE9BQU8sRUFBRSxFQUFFLGFBQWEsRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDO0lBRWhGLE9BQU8sT0FBTyxDQUFDLFdBQVcsRUFBRSxDQUFDO0FBQ2pDLENBQUM7QUFFRCxNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxXQUFXLEVBQUU7SUFDckMsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxtQkFBbUI7Q0FDdEMsQ0FBQyxDQUFDO0FBRUgsTUFBTSxhQUFhLEdBQUc7SUFDbEIsSUFBSTtJQUVKLGNBQWM7SUFFZCxRQUFRO0lBRVIsYUFBYTtJQUViLFdBQVc7SUFFWCxJQUFJLFdBQVc7UUFDWCxJQUFJLENBQUMsV0FBVztZQUNaLFdBQVcsR0FBRyxPQUFPLENBQUMsdUJBQXVCLENBQUMsQ0FBQztRQUVuRCxPQUFPLFdBQVcsQ0FBQztJQUN2QixDQUFDO0lBRUQsSUFBSSxDQUFDO1FBQ0QsSUFBSSxDQUFDLG1CQUFtQjtZQUNwQixtQkFBbUIsR0FBRyxPQUFPLENBQUMsMEJBQTBCLENBQUMsQ0FBQztRQUU5RCxPQUFPLG1CQUFtQixDQUFDO0lBQy9CLENBQUM7SUFFRCxJQUFJLGFBQWE7UUFDYixPQUFPLGFBQWEsQ0FBQyxLQUFLLENBQUM7SUFDL0IsQ0FBQztJQUVELElBQUksT0FBTztRQUNQLE9BQU8sa0JBQWtCLEVBQUUsQ0FBQztJQUNoQyxDQUFDO0NBQ0osQ0FBQztBQUVGLGtCQUFlLGFBQWEsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGxhenlSZXF1aXJlICAgICAgICAgICA9IHJlcXVpcmUoJ2ltcG9ydC1sYXp5JykocmVxdWlyZSk7XG5jb25zdCBDbGllbnRGdW5jdGlvbkJ1aWxkZXIgPSBsYXp5UmVxdWlyZSgnLi4vLi4vY2xpZW50LWZ1bmN0aW9ucy9jbGllbnQtZnVuY3Rpb24tYnVpbGRlcicpO1xuY29uc3QgU2VsZWN0b3JCdWlsZGVyICAgICAgID0gbGF6eVJlcXVpcmUoJy4uLy4uL2NsaWVudC1mdW5jdGlvbnMvc2VsZWN0b3JzL3NlbGVjdG9yLWJ1aWxkZXInKTtcbmNvbnN0IHJvbGUgICAgICAgICAgICAgICAgICA9IGxhenlSZXF1aXJlKCcuLi8uLi9yb2xlJyk7XG5jb25zdCBjcmVhdGVSZXF1ZXN0TG9nZ2VyICAgPSBsYXp5UmVxdWlyZSgnLi4vcmVxdWVzdC1ob29rcy9yZXF1ZXN0LWxvZ2dlcicpO1xuY29uc3QgY3JlYXRlUmVxdWVzdE1vY2sgICAgID0gbGF6eVJlcXVpcmUoJy4uL3JlcXVlc3QtaG9va3MvcmVxdWVzdC1tb2NrL2NyZWF0ZS1yZXF1ZXN0LW1vY2snKTtcbmNvbnN0IHVzZXJWYXJpYWJsZXMgICAgICAgICA9IGxhenlSZXF1aXJlKCcuLi91c2VyLXZhcmlhYmxlcycpO1xuY29uc3QgZ2V0VGVzdENhZmVWZXJzaW9uICAgID0gbGF6eVJlcXVpcmUoJy4uLy4uL3V0aWxzL2dldC10ZXN0Y2FmZS12ZXJzaW9uJyk7XG5cbi8vIE5PVEU6IFdlIGNhbid0IHVzZSBsYXp5IHJlcXVpcmUgZm9yIFJlcXVlc3RIb29rLCBiZWNhdXNlIGl0IHdpbGwgYnJlYWsgYmFzZSBjbGFzcyBkZXRlY3Rpb24gZm9yIGluaGVyaXRlZCBjbGFzc2VzXG5sZXQgUmVxdWVzdEhvb2sgPSBudWxsO1xuXG4vLyBOT1RFOiBXZSBjYW4ndCB1c2UgbGF6eSByZXF1aXJlIGZvciB0ZXN0Q29udHJvbGxlclByb3h5LCBiZWNhdXNlIGl0IHdpbGwgYnJlYWsgdGVzdCBjb250cm9sbGVyIGRldGVjdGlvblxubGV0IHRlc3RDb250cm9sbGVyUHJveHkgPSBudWxsO1xuXG5mdW5jdGlvbiBSb2xlIChsb2dpblVybCwgaW5pdEZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHJvbGUuY3JlYXRlUm9sZShsb2dpblVybCwgaW5pdEZuLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gUmVxdWVzdE1vY2sgKCkge1xuICAgIHJldHVybiBjcmVhdGVSZXF1ZXN0TW9jaygpO1xufVxuXG5mdW5jdGlvbiBSZXF1ZXN0TG9nZ2VyIChyZXF1ZXN0RmlsdGVyUnVsZUluaXQsIGxvZ09wdGlvbnMpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVxdWVzdExvZ2dlcihyZXF1ZXN0RmlsdGVyUnVsZUluaXQsIGxvZ09wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBDbGllbnRGdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBidWlsZGVyID0gbmV3IENsaWVudEZ1bmN0aW9uQnVpbGRlcihmbiwgb3B0aW9ucywgeyBpbnN0YW50aWF0aW9uOiAnQ2xpZW50RnVuY3Rpb24nIH0pO1xuXG4gICAgcmV0dXJuIGJ1aWxkZXIuZ2V0RnVuY3Rpb24oKTtcbn1cblxuZnVuY3Rpb24gU2VsZWN0b3IgKGZuLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYnVpbGRlciA9IG5ldyBTZWxlY3RvckJ1aWxkZXIoZm4sIG9wdGlvbnMsIHsgaW5zdGFudGlhdGlvbjogJ1NlbGVjdG9yJyB9KTtcblxuICAgIHJldHVybiBidWlsZGVyLmdldEZ1bmN0aW9uKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb2xlLCAnYW5vbnltb3VzJywge1xuICAgIGdldDogKCkgPT4gcm9sZS5jcmVhdGVBbm9ueW1vdXNSb2xlLFxufSk7XG5cbmNvbnN0IGV4cG9ydGFibGVMaWIgPSB7XG4gICAgUm9sZSxcblxuICAgIENsaWVudEZ1bmN0aW9uLFxuXG4gICAgU2VsZWN0b3IsXG5cbiAgICBSZXF1ZXN0TG9nZ2VyLFxuXG4gICAgUmVxdWVzdE1vY2ssXG5cbiAgICBnZXQgUmVxdWVzdEhvb2sgKCkge1xuICAgICAgICBpZiAoIVJlcXVlc3RIb29rKVxuICAgICAgICAgICAgUmVxdWVzdEhvb2sgPSByZXF1aXJlKCcuLi9yZXF1ZXN0LWhvb2tzL2hvb2snKTtcblxuICAgICAgICByZXR1cm4gUmVxdWVzdEhvb2s7XG4gICAgfSxcblxuICAgIGdldCB0ICgpIHtcbiAgICAgICAgaWYgKCF0ZXN0Q29udHJvbGxlclByb3h5KVxuICAgICAgICAgICAgdGVzdENvbnRyb2xsZXJQcm94eSA9IHJlcXVpcmUoJy4uL3Rlc3QtY29udHJvbGxlci9wcm94eScpO1xuXG4gICAgICAgIHJldHVybiB0ZXN0Q29udHJvbGxlclByb3h5O1xuICAgIH0sXG5cbiAgICBnZXQgdXNlclZhcmlhYmxlcyAoKSB7XG4gICAgICAgIHJldHVybiB1c2VyVmFyaWFibGVzLnZhbHVlO1xuICAgIH0sXG5cbiAgICBnZXQgdmVyc2lvbiAoKSB7XG4gICAgICAgIHJldHVybiBnZXRUZXN0Q2FmZVZlcnNpb24oKTtcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgZXhwb3J0YWJsZUxpYjtcblxuIl19