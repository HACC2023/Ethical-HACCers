"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const get_callsite_1 = require("./get-callsite");
const runtime_1 = require("./runtime");
const error_list_1 = __importDefault(require("./error-list"));
const internal_modules_prefix_1 = __importDefault(require("./internal-modules-prefix"));
const node_modules_folder_name_1 = __importDefault(require("../utils/node-modules-folder-name"));
const test_run_1 = require("./test-run");
const debug_1 = __importDefault(require("debug"));
const is_file_protocol_1 = __importDefault(require("../shared/utils/is-file-protocol"));
const debugLog = (0, debug_1.default)('testcafe:errors');
function isAssertionErrorCallsiteFrame(frame) {
    const filename = frame.getFileName();
    // NOTE: filter out the internals of node.js and assertion libraries
    return filename &&
        (filename.includes(path_1.sep) || (0, is_file_protocol_1.default)(filename)) &&
        !filename.startsWith(internal_modules_prefix_1.default) &&
        !filename.includes(`${path_1.sep}${node_modules_folder_name_1.default}${path_1.sep}`);
}
function processTestFnError(err) {
    debugLog('processTestFnError: %O', err);
    if (err && (err.isTestCafeError || err instanceof error_list_1.default))
        return err;
    if (err && err instanceof runtime_1.APIError)
        return new test_run_1.UncaughtErrorInTestCode(err);
    if (err instanceof Error) {
        const isAssertionError = err.name === 'AssertionError' || err.constructor.name === 'AssertionError';
        // NOTE: assertion libraries can add their source files to the error stack frames.
        // We should skip them to create a correct callsite for the assertion error.
        const callsite = isAssertionError ? (0, get_callsite_1.getCallsiteForError)(err, isAssertionErrorCallsiteFrame) : (0, get_callsite_1.getCallsiteForError)(err);
        return isAssertionError ?
            new test_run_1.ExternalAssertionLibraryError(err, callsite) :
            new test_run_1.UncaughtErrorInTestCode(err, callsite);
    }
    if (err && err.isInternalError)
        return new test_run_1.UncaughtExceptionError(err.stack);
    return new test_run_1.UncaughtNonErrorObjectInTestCode(err);
}
exports.default = processTestFnError;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvY2Vzcy10ZXN0LWZuLWVycm9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2Vycm9ycy9wcm9jZXNzLXRlc3QtZm4tZXJyb3IuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSwrQkFBMkI7QUFDM0IsaURBQXFEO0FBQ3JELHVDQUFxQztBQUNyQyw4REFBNkM7QUFDN0Msd0ZBQWdFO0FBQ2hFLGlHQUE2RDtBQUU3RCx5Q0FLb0I7QUFDcEIsa0RBQTBCO0FBQzFCLHdGQUE4RDtBQUU5RCxNQUFNLFFBQVEsR0FBRyxJQUFBLGVBQUssRUFBQyxpQkFBaUIsQ0FBQyxDQUFDO0FBRzFDLFNBQVMsNkJBQTZCLENBQUUsS0FBSztJQUN6QyxNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUM7SUFFckMsb0VBQW9FO0lBQ3BFLE9BQU8sUUFBUTtRQUNYLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxVQUFHLENBQUMsSUFBSSxJQUFBLDBCQUFjLEVBQUMsUUFBUSxDQUFDLENBQUM7UUFDcEQsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLGlDQUF1QixDQUFDO1FBQzdDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxHQUFHLFVBQUcsR0FBRyxrQ0FBWSxHQUFHLFVBQUcsRUFBRSxDQUFDLENBQUM7QUFDMUQsQ0FBQztBQUVELFNBQXdCLGtCQUFrQixDQUFFLEdBQUc7SUFDM0MsUUFBUSxDQUFDLHdCQUF3QixFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBRXhDLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLGVBQWUsSUFBSSxHQUFHLFlBQVksb0JBQWlCLENBQUM7UUFDaEUsT0FBTyxHQUFHLENBQUM7SUFFZixJQUFJLEdBQUcsSUFBSSxHQUFHLFlBQVksa0JBQVE7UUFDOUIsT0FBTyxJQUFJLGtDQUF1QixDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRTVDLElBQUksR0FBRyxZQUFZLEtBQUssRUFBRTtRQUN0QixNQUFNLGdCQUFnQixHQUFHLEdBQUcsQ0FBQyxJQUFJLEtBQUssZ0JBQWdCLElBQUksR0FBRyxDQUFDLFdBQVcsQ0FBQyxJQUFJLEtBQUssZ0JBQWdCLENBQUM7UUFFcEcsa0ZBQWtGO1FBQ2xGLDRFQUE0RTtRQUM1RSxNQUFNLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsSUFBQSxrQ0FBbUIsRUFBQyxHQUFHLEVBQUUsNkJBQTZCLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBQSxrQ0FBbUIsRUFBQyxHQUFHLENBQUMsQ0FBQztRQUV2SCxPQUFPLGdCQUFnQixDQUFDLENBQUM7WUFDckIsSUFBSSx3Q0FBNkIsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUNsRCxJQUFJLGtDQUF1QixDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQztLQUNsRDtJQUVELElBQUksR0FBRyxJQUFJLEdBQUcsQ0FBQyxlQUFlO1FBQzFCLE9BQU8sSUFBSSxpQ0FBc0IsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFFakQsT0FBTyxJQUFJLDJDQUFnQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3JELENBQUM7QUF6QkQscUNBeUJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2VwIH0gZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBnZXRDYWxsc2l0ZUZvckVycm9yIH0gZnJvbSAnLi9nZXQtY2FsbHNpdGUnO1xuaW1wb3J0IHsgQVBJRXJyb3IgfSBmcm9tICcuL3J1bnRpbWUnO1xuaW1wb3J0IFRlc3RDYWZlRXJyb3JMaXN0IGZyb20gJy4vZXJyb3ItbGlzdCc7XG5pbXBvcnQgSU5URVJOQUxfTU9EVUxFU19QUkVGSVggZnJvbSAnLi9pbnRlcm5hbC1tb2R1bGVzLXByZWZpeCc7XG5pbXBvcnQgTk9ERV9NT0RVTEVTIGZyb20gJy4uL3V0aWxzL25vZGUtbW9kdWxlcy1mb2xkZXItbmFtZSc7XG5cbmltcG9ydCB7XG4gICAgVW5jYXVnaHRFcnJvckluVGVzdENvZGUsXG4gICAgVW5jYXVnaHROb25FcnJvck9iamVjdEluVGVzdENvZGUsXG4gICAgRXh0ZXJuYWxBc3NlcnRpb25MaWJyYXJ5RXJyb3IsXG4gICAgVW5jYXVnaHRFeGNlcHRpb25FcnJvcixcbn0gZnJvbSAnLi90ZXN0LXJ1bic7XG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IGlzRmlsZVByb3RvY29sIGZyb20gJy4uL3NoYXJlZC91dGlscy9pcy1maWxlLXByb3RvY29sJztcblxuY29uc3QgZGVidWdMb2cgPSBkZWJ1ZygndGVzdGNhZmU6ZXJyb3JzJyk7XG5cblxuZnVuY3Rpb24gaXNBc3NlcnRpb25FcnJvckNhbGxzaXRlRnJhbWUgKGZyYW1lKSB7XG4gICAgY29uc3QgZmlsZW5hbWUgPSBmcmFtZS5nZXRGaWxlTmFtZSgpO1xuXG4gICAgLy8gTk9URTogZmlsdGVyIG91dCB0aGUgaW50ZXJuYWxzIG9mIG5vZGUuanMgYW5kIGFzc2VydGlvbiBsaWJyYXJpZXNcbiAgICByZXR1cm4gZmlsZW5hbWUgJiZcbiAgICAgICAgKGZpbGVuYW1lLmluY2x1ZGVzKHNlcCkgfHwgaXNGaWxlUHJvdG9jb2woZmlsZW5hbWUpKSAmJlxuICAgICAgICAhZmlsZW5hbWUuc3RhcnRzV2l0aChJTlRFUk5BTF9NT0RVTEVTX1BSRUZJWCkgJiZcbiAgICAgICAgIWZpbGVuYW1lLmluY2x1ZGVzKGAke3NlcH0ke05PREVfTU9EVUxFU30ke3NlcH1gKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHJvY2Vzc1Rlc3RGbkVycm9yIChlcnIpIHtcbiAgICBkZWJ1Z0xvZygncHJvY2Vzc1Rlc3RGbkVycm9yOiAlTycsIGVycik7XG5cbiAgICBpZiAoZXJyICYmIChlcnIuaXNUZXN0Q2FmZUVycm9yIHx8IGVyciBpbnN0YW5jZW9mIFRlc3RDYWZlRXJyb3JMaXN0KSlcbiAgICAgICAgcmV0dXJuIGVycjtcblxuICAgIGlmIChlcnIgJiYgZXJyIGluc3RhbmNlb2YgQVBJRXJyb3IpXG4gICAgICAgIHJldHVybiBuZXcgVW5jYXVnaHRFcnJvckluVGVzdENvZGUoZXJyKTtcblxuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBjb25zdCBpc0Fzc2VydGlvbkVycm9yID0gZXJyLm5hbWUgPT09ICdBc3NlcnRpb25FcnJvcicgfHwgZXJyLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBc3NlcnRpb25FcnJvcic7XG5cbiAgICAgICAgLy8gTk9URTogYXNzZXJ0aW9uIGxpYnJhcmllcyBjYW4gYWRkIHRoZWlyIHNvdXJjZSBmaWxlcyB0byB0aGUgZXJyb3Igc3RhY2sgZnJhbWVzLlxuICAgICAgICAvLyBXZSBzaG91bGQgc2tpcCB0aGVtIHRvIGNyZWF0ZSBhIGNvcnJlY3QgY2FsbHNpdGUgZm9yIHRoZSBhc3NlcnRpb24gZXJyb3IuXG4gICAgICAgIGNvbnN0IGNhbGxzaXRlID0gaXNBc3NlcnRpb25FcnJvciA/IGdldENhbGxzaXRlRm9yRXJyb3IoZXJyLCBpc0Fzc2VydGlvbkVycm9yQ2FsbHNpdGVGcmFtZSkgOiBnZXRDYWxsc2l0ZUZvckVycm9yKGVycik7XG5cbiAgICAgICAgcmV0dXJuIGlzQXNzZXJ0aW9uRXJyb3IgP1xuICAgICAgICAgICAgbmV3IEV4dGVybmFsQXNzZXJ0aW9uTGlicmFyeUVycm9yKGVyciwgY2FsbHNpdGUpIDpcbiAgICAgICAgICAgIG5ldyBVbmNhdWdodEVycm9ySW5UZXN0Q29kZShlcnIsIGNhbGxzaXRlKTtcbiAgICB9XG5cbiAgICBpZiAoZXJyICYmIGVyci5pc0ludGVybmFsRXJyb3IpXG4gICAgICAgIHJldHVybiBuZXcgVW5jYXVnaHRFeGNlcHRpb25FcnJvcihlcnIuc3RhY2spO1xuXG4gICAgcmV0dXJuIG5ldyBVbmNhdWdodE5vbkVycm9yT2JqZWN0SW5UZXN0Q29kZShlcnIpO1xufVxuIl19