"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertType = exports.is = void 0;
const lodash_1 = require("lodash");
const _1 = require("./");
const types_1 = require("../types");
const hook_1 = __importDefault(require("../../api/request-hooks/hook"));
const test_timeout_1 = __importDefault(require("../../api/structure/test-timeout"));
const START_FROM_VOWEL_RE = /^[aeiou]/i;
function getIndefiniteArticle(text) {
    return START_FROM_VOWEL_RE.test(text) ? 'an' : 'a';
}
function isNonNegativeValue(value) {
    return (0, lodash_1.isFinite)(value) && value >= 0;
}
function getNumberTypeActualValueMsg(value, type) {
    if (type !== 'number')
        return type;
    if (Number.isNaN(value))
        return NaN;
    if (!(0, lodash_1.isFinite)(value))
        return Infinity;
    return value;
}
function hasSomePropInObject(obj, props) {
    return !!obj &&
        typeof obj === 'object' &&
        props.some(prop => prop in obj);
}
exports.is = {
    number: {
        name: 'number',
        predicate: lodash_1.isFinite,
        getActualValueMsg: getNumberTypeActualValueMsg,
    },
    nonNegativeNumber: {
        name: 'non-negative number',
        predicate: isNonNegativeValue,
        getActualValueMsg: getNumberTypeActualValueMsg,
    },
    nonNegativeNumberString: {
        name: 'non-negative number',
        predicate: value => isNonNegativeValue(parseInt(value, 10)),
        getActualValueMsg: value => {
            const number = parseInt(value, 10);
            return isNaN(number) ? JSON.stringify(value) : number;
        },
    },
    boolean: {
        name: 'boolean',
        predicate: (value, type) => type === 'boolean',
    },
    string: {
        name: 'string',
        predicate: (value, type) => type === 'string',
    },
    function: {
        name: 'function',
        predicate: (value, type) => type === 'function',
    },
    regExp: {
        name: 'regular expression',
        predicate: lodash_1.isRegExp,
    },
    array: {
        name: 'array',
        predicate: value => Array.isArray(value),
    },
    nonNullObject: {
        name: 'non-null object',
        predicate: (value, type) => type === 'object' && !(0, lodash_1.isNil)(value),
        getActualValueMsg: (value, type) => (0, lodash_1.isNil)(value) ? String(value) : type,
    },
    requestHookSubclass: {
        name: 'RequestHook subclass',
        predicate: value => value instanceof hook_1.default && value.constructor && value.constructor !== hook_1.default,
    },
    clientScriptInitializer: {
        name: 'client script initializer',
        predicate: obj => hasSomePropInObject(obj, ['path', 'content', 'module']),
    },
    testTimeouts: {
        name: 'test timeouts initializer',
        predicate: obj => hasSomePropInObject(obj, Object.keys(test_timeout_1.default)),
    },
};
function assertType(types, callsiteName, what, value) {
    types = (0, lodash_1.castArray)(types);
    let pass = false;
    const actualType = typeof value;
    let actualMsg = actualType;
    let expectedTypeMsg = '';
    const last = types.length - 1;
    types.forEach((type, i) => {
        pass = pass || type.predicate(value, actualType);
        if (type.getActualValueMsg)
            actualMsg = type.getActualValueMsg(value, actualType);
        if (i === 0)
            expectedTypeMsg += type.name;
        else
            expectedTypeMsg += (i === last ? ' or ' + getIndefiniteArticle(type.name) + ' ' : ', ') + type.name;
    });
    if (!pass) {
        throw callsiteName ?
            new _1.APIError(callsiteName, types_1.RUNTIME_ERRORS.invalidValueType, what, actualMsg, expectedTypeMsg) :
            new _1.GeneralError(types_1.RUNTIME_ERRORS.invalidValueType, what, actualMsg, expectedTypeMsg);
    }
}
exports.assertType = assertType;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS1hc3NlcnRpb25zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2Vycm9ycy9ydW50aW1lL3R5cGUtYXNzZXJ0aW9ucy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxtQ0FLZ0I7QUFFaEIseUJBQTRDO0FBQzVDLG9DQUEwQztBQUMxQyx3RUFBdUQ7QUFDdkQsb0ZBQTJEO0FBRTNELE1BQU0sbUJBQW1CLEdBQUcsV0FBVyxDQUFDO0FBRXhDLFNBQVMsb0JBQW9CLENBQUUsSUFBSTtJQUMvQixPQUFPLG1CQUFtQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7QUFDdkQsQ0FBQztBQUVELFNBQVMsa0JBQWtCLENBQUUsS0FBSztJQUM5QixPQUFPLElBQUEsaUJBQWMsRUFBQyxLQUFLLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQyxDQUFDO0FBQy9DLENBQUM7QUFFRCxTQUFTLDJCQUEyQixDQUFFLEtBQUssRUFBRSxJQUFJO0lBQzdDLElBQUksSUFBSSxLQUFLLFFBQVE7UUFDakIsT0FBTyxJQUFJLENBQUM7SUFFaEIsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztRQUNuQixPQUFPLEdBQUcsQ0FBQztJQUVmLElBQUksQ0FBQyxJQUFBLGlCQUFjLEVBQUMsS0FBSyxDQUFDO1FBQ3RCLE9BQU8sUUFBUSxDQUFDO0lBRXBCLE9BQU8sS0FBSyxDQUFDO0FBQ2pCLENBQUM7QUFFRCxTQUFTLG1CQUFtQixDQUFFLEdBQUcsRUFBRSxLQUFLO0lBQ3BDLE9BQU8sQ0FBQyxDQUFDLEdBQUc7UUFDUixPQUFPLEdBQUcsS0FBSyxRQUFRO1FBQ3ZCLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLElBQUksR0FBRyxDQUFDLENBQUM7QUFDeEMsQ0FBQztBQUVZLFFBQUEsRUFBRSxHQUFH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QkQsZ0NBMEJDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBpc0Zpbml0ZSBhcyBpc0Zpbml0ZU51bWJlcixcbiAgICBpc1JlZ0V4cCxcbiAgICBpc05pbCBhcyBpc051bGxPclVuZGVmaW5lZCxcbiAgICBjYXN0QXJyYXksXG59IGZyb20gJ2xvZGFzaCc7XG5cbmltcG9ydCB7IEFQSUVycm9yLCBHZW5lcmFsRXJyb3IgfSBmcm9tICcuLyc7XG5pbXBvcnQgeyBSVU5USU1FX0VSUk9SUyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCBSZXF1ZXN0SG9vayBmcm9tICcuLi8uLi9hcGkvcmVxdWVzdC1ob29rcy9ob29rJztcbmltcG9ydCBUZXN0VGltZW91dCBmcm9tICcuLi8uLi9hcGkvc3RydWN0dXJlL3Rlc3QtdGltZW91dCc7XG5cbmNvbnN0IFNUQVJUX0ZST01fVk9XRUxfUkUgPSAvXlthZWlvdV0vaTtcblxuZnVuY3Rpb24gZ2V0SW5kZWZpbml0ZUFydGljbGUgKHRleHQpIHtcbiAgICByZXR1cm4gU1RBUlRfRlJPTV9WT1dFTF9SRS50ZXN0KHRleHQpID8gJ2FuJyA6ICdhJztcbn1cblxuZnVuY3Rpb24gaXNOb25OZWdhdGl2ZVZhbHVlICh2YWx1ZSkge1xuICAgIHJldHVybiBpc0Zpbml0ZU51bWJlcih2YWx1ZSkgJiYgdmFsdWUgPj0gMDtcbn1cblxuZnVuY3Rpb24gZ2V0TnVtYmVyVHlwZUFjdHVhbFZhbHVlTXNnICh2YWx1ZSwgdHlwZSkge1xuICAgIGlmICh0eXBlICE9PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICBpZiAoTnVtYmVyLmlzTmFOKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIE5hTjtcblxuICAgIGlmICghaXNGaW5pdGVOdW1iZXIodmFsdWUpKVxuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGhhc1NvbWVQcm9wSW5PYmplY3QgKG9iaiwgcHJvcHMpIHtcbiAgICByZXR1cm4gISFvYmogJiZcbiAgICAgICAgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgcHJvcHMuc29tZShwcm9wID0+IHByb3AgaW4gb2JqKTtcbn1cblxuZXhwb3J0IGNvbnN0IGlzID0ge1xuICAgIG51bWJlcjoge1xuICAgICAgICBuYW1lOiAgICAgICAgICAgICAgJ251bWJlcicsXG4gICAgICAgIHByZWRpY2F0ZTogICAgICAgICBpc0Zpbml0ZU51bWJlcixcbiAgICAgICAgZ2V0QWN0dWFsVmFsdWVNc2c6IGdldE51bWJlclR5cGVBY3R1YWxWYWx1ZU1zZyxcbiAgICB9LFxuXG4gICAgbm9uTmVnYXRpdmVOdW1iZXI6IHtcbiAgICAgICAgbmFtZTogICAgICAgICAgICAgICdub24tbmVnYXRpdmUgbnVtYmVyJyxcbiAgICAgICAgcHJlZGljYXRlOiAgICAgICAgIGlzTm9uTmVnYXRpdmVWYWx1ZSxcbiAgICAgICAgZ2V0QWN0dWFsVmFsdWVNc2c6IGdldE51bWJlclR5cGVBY3R1YWxWYWx1ZU1zZyxcbiAgICB9LFxuXG4gICAgbm9uTmVnYXRpdmVOdW1iZXJTdHJpbmc6IHtcbiAgICAgICAgbmFtZTogICAgICAnbm9uLW5lZ2F0aXZlIG51bWJlcicsXG4gICAgICAgIHByZWRpY2F0ZTogdmFsdWUgPT4gaXNOb25OZWdhdGl2ZVZhbHVlKHBhcnNlSW50KHZhbHVlLCAxMCkpLFxuXG4gICAgICAgIGdldEFjdHVhbFZhbHVlTXNnOiB2YWx1ZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBudW1iZXIgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuXG4gICAgICAgICAgICByZXR1cm4gaXNOYU4obnVtYmVyKSA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IG51bWJlcjtcbiAgICAgICAgfSxcbiAgICB9LFxuXG4gICAgYm9vbGVhbjoge1xuICAgICAgICBuYW1lOiAgICAgICdib29sZWFuJyxcbiAgICAgICAgcHJlZGljYXRlOiAodmFsdWUsIHR5cGUpID0+IHR5cGUgPT09ICdib29sZWFuJyxcbiAgICB9LFxuXG4gICAgc3RyaW5nOiB7XG4gICAgICAgIG5hbWU6ICAgICAgJ3N0cmluZycsXG4gICAgICAgIHByZWRpY2F0ZTogKHZhbHVlLCB0eXBlKSA9PiB0eXBlID09PSAnc3RyaW5nJyxcbiAgICB9LFxuXG4gICAgZnVuY3Rpb246IHtcbiAgICAgICAgbmFtZTogICAgICAnZnVuY3Rpb24nLFxuICAgICAgICBwcmVkaWNhdGU6ICh2YWx1ZSwgdHlwZSkgPT4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyxcbiAgICB9LFxuXG4gICAgcmVnRXhwOiB7XG4gICAgICAgIG5hbWU6ICAgICAgJ3JlZ3VsYXIgZXhwcmVzc2lvbicsXG4gICAgICAgIHByZWRpY2F0ZTogaXNSZWdFeHAsXG4gICAgfSxcblxuICAgIGFycmF5OiB7XG4gICAgICAgIG5hbWU6ICAgICAgJ2FycmF5JyxcbiAgICAgICAgcHJlZGljYXRlOiB2YWx1ZSA9PiBBcnJheS5pc0FycmF5KHZhbHVlKSxcbiAgICB9LFxuXG4gICAgbm9uTnVsbE9iamVjdDoge1xuICAgICAgICBuYW1lOiAgICAgICAgICAgICAgJ25vbi1udWxsIG9iamVjdCcsXG4gICAgICAgIHByZWRpY2F0ZTogICAgICAgICAodmFsdWUsIHR5cGUpID0+IHR5cGUgPT09ICdvYmplY3QnICYmICFpc051bGxPclVuZGVmaW5lZCh2YWx1ZSksXG4gICAgICAgIGdldEFjdHVhbFZhbHVlTXNnOiAodmFsdWUsIHR5cGUpID0+IGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiB0eXBlLFxuICAgIH0sXG5cbiAgICByZXF1ZXN0SG9va1N1YmNsYXNzOiB7XG4gICAgICAgIG5hbWU6ICAgICAgJ1JlcXVlc3RIb29rIHN1YmNsYXNzJyxcbiAgICAgICAgcHJlZGljYXRlOiB2YWx1ZSA9PiB2YWx1ZSBpbnN0YW5jZW9mIFJlcXVlc3RIb29rICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yICE9PSBSZXF1ZXN0SG9vayxcbiAgICB9LFxuXG4gICAgY2xpZW50U2NyaXB0SW5pdGlhbGl6ZXI6IHtcbiAgICAgICAgbmFtZTogICAgICAnY2xpZW50IHNjcmlwdCBpbml0aWFsaXplcicsXG4gICAgICAgIHByZWRpY2F0ZTogb2JqID0+IGhhc1NvbWVQcm9wSW5PYmplY3Qob2JqLCBbJ3BhdGgnLCAnY29udGVudCcsICdtb2R1bGUnXSksXG4gICAgfSxcblxuICAgIHRlc3RUaW1lb3V0czoge1xuICAgICAgICBuYW1lOiAgICAgICd0ZXN0IHRpbWVvdXRzIGluaXRpYWxpemVyJyxcbiAgICAgICAgcHJlZGljYXRlOiBvYmogPT4gaGFzU29tZVByb3BJbk9iamVjdChvYmosIE9iamVjdC5rZXlzKFRlc3RUaW1lb3V0KSksXG4gICAgfSxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRUeXBlICh0eXBlcywgY2FsbHNpdGVOYW1lLCB3aGF0LCB2YWx1ZSkge1xuICAgIHR5cGVzID0gY2FzdEFycmF5KHR5cGVzKTtcblxuICAgIGxldCBwYXNzICAgICAgICAgICAgPSBmYWxzZTtcbiAgICBjb25zdCBhY3R1YWxUeXBlICAgID0gdHlwZW9mIHZhbHVlO1xuICAgIGxldCBhY3R1YWxNc2cgICAgICAgPSBhY3R1YWxUeXBlO1xuICAgIGxldCBleHBlY3RlZFR5cGVNc2cgPSAnJztcbiAgICBjb25zdCBsYXN0ICAgICAgICAgICAgPSB0eXBlcy5sZW5ndGggLSAxO1xuXG4gICAgdHlwZXMuZm9yRWFjaCgodHlwZSwgaSkgPT4ge1xuICAgICAgICBwYXNzID0gcGFzcyB8fCB0eXBlLnByZWRpY2F0ZSh2YWx1ZSwgYWN0dWFsVHlwZSk7XG5cbiAgICAgICAgaWYgKHR5cGUuZ2V0QWN0dWFsVmFsdWVNc2cpXG4gICAgICAgICAgICBhY3R1YWxNc2cgPSB0eXBlLmdldEFjdHVhbFZhbHVlTXNnKHZhbHVlLCBhY3R1YWxUeXBlKTtcblxuICAgICAgICBpZiAoaSA9PT0gMClcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZU1zZyArPSB0eXBlLm5hbWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZU1zZyArPSAoaSA9PT0gbGFzdCA/ICcgb3IgJyArIGdldEluZGVmaW5pdGVBcnRpY2xlKHR5cGUubmFtZSkgKyAnICcgOiAnLCAnKSArIHR5cGUubmFtZTtcbiAgICB9KTtcblxuICAgIGlmICghcGFzcykge1xuICAgICAgICB0aHJvdyBjYWxsc2l0ZU5hbWUgP1xuICAgICAgICAgICAgbmV3IEFQSUVycm9yKGNhbGxzaXRlTmFtZSwgUlVOVElNRV9FUlJPUlMuaW52YWxpZFZhbHVlVHlwZSwgd2hhdCwgYWN0dWFsTXNnLCBleHBlY3RlZFR5cGVNc2cpIDpcbiAgICAgICAgICAgIG5ldyBHZW5lcmFsRXJyb3IoUlVOVElNRV9FUlJPUlMuaW52YWxpZFZhbHVlVHlwZSwgd2hhdCwgYWN0dWFsTXNnLCBleHBlY3RlZFR5cGVNc2cpO1xuICAgIH1cbn1cbiJdfQ==