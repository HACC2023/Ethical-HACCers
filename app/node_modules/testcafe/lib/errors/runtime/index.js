"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoadReporterError = exports.ReadConfigFileError = exports.ImportESMInCommonJSError = exports.SkipJsErrorsArgumentApiError = exports.RequestRuntimeError = exports.BrowserConnectionError = exports.TimeoutError = exports.ReporterPluginError = exports.CompositeError = exports.ClientFunctionAPIError = exports.APIError = exports.TestCompilationError = exports.GeneralError = void 0;
const templates_1 = __importDefault(require("./templates"));
const create_stack_filter_1 = __importDefault(require("../create-stack-filter"));
const get_callsite_1 = require("../get-callsite");
const render_template_1 = __importDefault(require("../../utils/render-template"));
const render_callsite_sync_1 = __importDefault(require("../../utils/render-callsite-sync"));
const types_1 = require("../types");
const get_renderes_1 = __importDefault(require("../../utils/get-renderes"));
const util_1 = __importDefault(require("util"));
const semver_1 = __importDefault(require("semver"));
const utils_1 = require("../test-run/utils");
const module_prefix_1 = __importDefault(require("../../reporter/module-prefix"));
const ERROR_SEPARATOR = '\n\n';
const NO_STACK_AVAILABLE_MSG = 'No stack trace is available for this error';
const MODULE_NOT_FOUND_CODE = 'MODULE_NOT_FOUND';
function formatErrorWithCallsite(error) {
    let formattedMessage = '';
    try {
        const callsite = (0, get_callsite_1.getCallsiteForError)(error);
        const stackFilter = (0, create_stack_filter_1.default)();
        // NOTE: If file from stack doesn't exist an error will be raised here:
        formattedMessage = (callsite === null || callsite === void 0 ? void 0 : callsite.renderSync({ stackFilter })) || NO_STACK_AVAILABLE_MSG;
    }
    catch (_a) {
        formattedMessage = NO_STACK_AVAILABLE_MSG;
    }
    return `${error.message}\n\n${formattedMessage}`;
}
function isModuleNotFoundError(error) {
    return error.code && error.code === MODULE_NOT_FOUND_CODE;
}
// NOTE: The "message" property of the ModuleNotFound error has the following pattern: <message>\nRequire stack:\n<line1>\n<line2>.
// This code removes lines bellow the targetPath. In case of "require('testcafe-reporter-<name>')" it removes all the Require stack.
function formatModuleNotFoundErrorRequireStack(message, targetPath) {
    const messageLines = message.split('\n');
    const targetLineIndex = messageLines.findIndex(line => line.includes(targetPath));
    if (targetLineIndex === -1)
        return message;
    return messageLines.slice(0, targetLineIndex + 1).join('\n');
}
class ProcessTemplateInstruction {
    constructor(processFn) {
        this.processFn = processFn;
    }
}
// Errors
class GeneralError extends Error {
    constructor(...args) {
        const code = args.shift();
        const template = templates_1.default[code];
        super((0, render_template_1.default)(template, ...args));
        Object.assign(this, { code, data: args });
        Error.captureStackTrace(this, GeneralError);
    }
    static isGeneralError(arg) {
        return arg instanceof GeneralError;
    }
}
exports.GeneralError = GeneralError;
class TestCompilationError extends Error {
    constructor(originalError) {
        const template = templates_1.default[types_1.RUNTIME_ERRORS.cannotPrepareTestsDueToError];
        const errorMessage = (0, utils_1.removePreventModuleCachingSuffix)(originalError.toString());
        super((0, render_template_1.default)(template, errorMessage));
        Object.assign(this, {
            code: types_1.RUNTIME_ERRORS.cannotPrepareTestsDueToError,
            data: [errorMessage],
        });
        // NOTE: The stack includes the error message.
        this.stack = (0, render_template_1.default)(template, (0, utils_1.removePreventModuleCachingSuffix)(originalError.stack));
    }
}
exports.TestCompilationError = TestCompilationError;
class APIError extends Error {
    constructor(callsite, code, ...args) {
        let template = templates_1.default[code];
        template = APIError._prepareTemplateAndArgsIfNecessary(template, args);
        const rawMessage = (0, render_template_1.default)(template, ...args);
        super((0, render_template_1.default)(templates_1.default[types_1.RUNTIME_ERRORS.cannotPrepareTestsDueToError], rawMessage));
        Object.assign(this, { code, data: args });
        // NOTE: `rawMessage` is used in error substitution if it occurs in test run.
        this.rawMessage = rawMessage;
        if (typeof callsite === 'object')
            this.callsite = callsite;
        else
            this.callsite = (0, get_callsite_1.getCallsiteForMethod)(callsite);
        // NOTE: Property getters are necessary because the callsite can be replaced with external code.
        // See https://github.com/DevExpress/testcafe/blob/v1.0.0/src/compiler/test-file/formats/raw.js#L22
        // Also we can't use an ES6 getter for the 'stack' property, because it will create a getter on the class prototype
        // that cannot override the instance property created by the Error parent class.
        const renderers = (0, get_renderes_1.default)(this.callsite);
        Object.defineProperties(this, {
            'stack': {
                get: () => this._createStack(renderers.noColor),
            },
            'coloredStack': {
                get: () => this._createStack(renderers.default),
            },
        });
    }
    _createStack(renderer) {
        const renderedCallsite = (0, render_callsite_sync_1.default)(this.callsite, {
            renderer: renderer,
            stackFilter: (0, create_stack_filter_1.default)(Error.stackTraceLimit),
        });
        if (!renderedCallsite)
            return this.message;
        return this.message + ERROR_SEPARATOR + renderedCallsite;
    }
    static _prepareTemplateAndArgsIfNecessary(template, args) {
        const lastArg = args.pop();
        if (lastArg instanceof ProcessTemplateInstruction)
            template = lastArg.processFn(template);
        else
            args.push(lastArg);
        return template;
    }
}
exports.APIError = APIError;
class ClientFunctionAPIError extends APIError {
    constructor(methodName, instantiationCallsiteName, code, ...args) {
        args.push(new ProcessTemplateInstruction(template => template.replace(/\{#instantiationCallsiteName\}/g, instantiationCallsiteName)));
        super(methodName, code, ...args);
    }
}
exports.ClientFunctionAPIError = ClientFunctionAPIError;
class CompositeError extends Error {
    constructor(errors) {
        super(errors.map(({ message }) => message).join(ERROR_SEPARATOR));
        this.stack = errors.map(({ stack }) => stack).join(ERROR_SEPARATOR);
        this.code = types_1.RUNTIME_ERRORS.compositeArgumentsError;
    }
}
exports.CompositeError = CompositeError;
class ReporterPluginError extends GeneralError {
    constructor({ name, method, originalError }) {
        const code = types_1.RUNTIME_ERRORS.uncaughtErrorInReporter;
        const preparedStack = ReporterPluginError._prepareStack(originalError);
        super(code, method, name, preparedStack);
    }
    static _prepareStack(err) {
        if (!(err === null || err === void 0 ? void 0 : err.stack)) {
            const inspectedObject = util_1.default.inspect(err);
            return `No stack trace is available for the raised error.\nError object inspection:\n${inspectedObject}`;
        }
        return err.stack;
    }
}
exports.ReporterPluginError = ReporterPluginError;
class TimeoutError extends GeneralError {
    constructor() {
        super(types_1.RUNTIME_ERRORS.timeLimitedPromiseTimeoutExpired);
    }
}
exports.TimeoutError = TimeoutError;
class BrowserConnectionError extends GeneralError {
    constructor(...args) {
        super(types_1.RUNTIME_ERRORS.browserConnectionError, ...args);
    }
}
exports.BrowserConnectionError = BrowserConnectionError;
class RequestRuntimeError extends APIError {
    constructor(methodName, code, ...args) {
        super(methodName, code, ...args);
    }
}
exports.RequestRuntimeError = RequestRuntimeError;
class SkipJsErrorsArgumentApiError extends APIError {
    constructor(code, ...args) {
        super('skipJsErrors', code, ...args);
    }
}
exports.SkipJsErrorsArgumentApiError = SkipJsErrorsArgumentApiError;
class ImportESMInCommonJSError extends GeneralError {
    constructor(originalError, targetFile) {
        const esModule = ImportESMInCommonJSError._getESModule(originalError);
        super(types_1.RUNTIME_ERRORS.cannotImportESMInCommonsJS, esModule, targetFile);
    }
    static _getESModule(err) {
        const regExp = semver_1.default.gte(process.version, '16.0.0') ? new RegExp(/ES Module (\S*)/) : /ES Module: (\S*)/;
        const [, esModule] = err.toString().match(regExp);
        return esModule;
    }
}
exports.ImportESMInCommonJSError = ImportESMInCommonJSError;
class ReadConfigFileError extends GeneralError {
    constructor(code, originalError, filePath, renderCallsite) {
        super(code, filePath, ReadConfigFileError._getFormattedMessage(originalError, renderCallsite, filePath));
    }
    static _getFormattedMessage(originalError, renderCallsite, filePath) {
        if (!renderCallsite)
            return originalError.message;
        if (isModuleNotFoundError(originalError))
            return formatModuleNotFoundErrorRequireStack(originalError.message, filePath);
        return formatErrorWithCallsite(originalError);
    }
}
exports.ReadConfigFileError = ReadConfigFileError;
class LoadReporterError extends GeneralError {
    constructor(originalError, reporterFullName) {
        const reporterShortName = LoadReporterError._ensureShortName(reporterFullName);
        const formattedOriginalError = LoadReporterError._getFormattedMessage(originalError, reporterFullName);
        super(types_1.RUNTIME_ERRORS.cannotFindReporterForAlias, reporterShortName, formattedOriginalError);
    }
    static _ensureShortName(name) {
        if (name && name.startsWith(module_prefix_1.default))
            return name.replace(module_prefix_1.default, '');
        return name;
    }
    static _getFormattedMessage(originalError, reporterFullName) {
        if (isModuleNotFoundError(originalError))
            return formatModuleNotFoundErrorRequireStack(originalError.message, reporterFullName);
        return formatErrorWithCallsite(originalError);
    }
}
exports.LoadReporterError = LoadReporterError;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvZXJyb3JzL3J1bnRpbWUvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsNERBQW9DO0FBQ3BDLGlGQUF1RDtBQUN2RCxrREFBNEU7QUFDNUUsa0ZBQXlEO0FBQ3pELDRGQUFrRTtBQUNsRSxvQ0FBMEM7QUFDMUMsNEVBQW9EO0FBQ3BELGdEQUF3QjtBQUN4QixvREFBNEI7QUFDNUIsNkNBQXFFO0FBQ3JFLGlGQUFrRTtBQUVsRSxNQUFNLGVBQWUsR0FBVSxNQUFNLENBQUM7QUFDdEMsTUFBTSxzQkFBc0IsR0FBRyw0Q0FBNEMsQ0FBQztBQUM1RSxNQUFNLHFCQUFxQixHQUFJLGtCQUFrQixDQUFDO0FBRWxELFNBQVMsdUJBQXVCLENBQUUsS0FBSztJQUNuQyxJQUFJLGdCQUFnQixHQUFHLEVBQUUsQ0FBQztJQUUxQixJQUFJO1FBQ0EsTUFBTSxRQUFRLEdBQU0sSUFBQSxrQ0FBbUIsRUFBQyxLQUFLLENBQUMsQ0FBQztRQUMvQyxNQUFNLFdBQVcsR0FBRyxJQUFBLDZCQUFpQixHQUFFLENBQUM7UUFFeEMsdUVBQXVFO1FBQ3ZFLGdCQUFnQixHQUFHLENBQUEsUUFBUSxhQUFSLFFBQVEsdUJBQVIsUUFBUSxDQUFFLFVBQVUsQ0FBQyxFQUFFLFdBQVcsRUFBRSxDQUFDLEtBQUksc0JBQXNCLENBQUM7S0FDdEY7SUFDRCxXQUFNO1FBQ0YsZ0JBQWdCLEdBQUcsc0JBQXNCLENBQUM7S0FDN0M7SUFFRCxPQUFPLEdBQUcsS0FBSyxDQUFDLE9BQU8sT0FBTyxnQkFBZ0IsRUFBRSxDQUFDO0FBQ3JELENBQUM7QUFFRCxTQUFTLHFCQUFxQixDQUFFLEtBQUs7SUFDakMsT0FBTyxLQUFLLENBQUMsSUFBSSxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUsscUJBQXFCLENBQUM7QUFDOUQsQ0FBQztBQUVELG1JQUFtSTtBQUNuSSxvSUFBb0k7QUFDcEksU0FB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Tyx1QkFBdUIsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUNsRCxDQUFDO0NBQ0o7QUFkRCxrREFjQztBQUVELE1BQWEsaUJBQWtCLFNBQVEsWUFBWTtJQUMvQyxZQUFhLGFBQWEsRUFBRSxnQkFBZ0I7UUFDeEMsTUFBTSxpQkFBaUIsR0FBUSxpQkFBaUIsQ0FBQyxnQkFBZ0IsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBQ3BGLE1BQU0sc0JBQXNCLEdBQUcsaUJBQWlCLENBQUMsb0JBQW9CLENBQUMsYUFBYSxFQUFFLGdCQUFnQixDQUFDLENBQUM7UUFFdkcsS0FBSyxDQUFDLHNCQUFjLENBQUMsMEJBQTBCLEVBQUUsaUJBQWlCLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztJQUNoRyxDQUFDO0lBRUQsTUFBTSxDQUFDLGdCQUFnQixDQUFFLElBQUk7UUFDekIsSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyx1QkFBc0IsQ0FBQztZQUMvQyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsdUJBQXNCLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFcEQsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVELE1BQU0sQ0FBQyxvQkFBb0IsQ0FBRSxhQUFhLEVBQUUsZ0JBQWdCO1FBQ3hELElBQUkscUJBQXFCLENBQUMsYUFBYSxDQUFDO1lBQ3BDLE9BQU8scUNBQXFDLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO1FBRTFGLE9BQU8sdUJBQXVCLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDbEQsQ0FBQztDQUNKO0FBckJELDhDQXFCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBURU1QTEFURVMgZnJvbSAnLi90ZW1wbGF0ZXMnO1xuaW1wb3J0IGNyZWF0ZVN0YWNrRmlsdGVyIGZyb20gJy4uL2NyZWF0ZS1zdGFjay1maWx0ZXInO1xuaW1wb3J0IHsgZ2V0Q2FsbHNpdGVGb3JFcnJvciwgZ2V0Q2FsbHNpdGVGb3JNZXRob2QgfSBmcm9tICcuLi9nZXQtY2FsbHNpdGUnO1xuaW1wb3J0IHJlbmRlclRlbXBsYXRlIGZyb20gJy4uLy4uL3V0aWxzL3JlbmRlci10ZW1wbGF0ZSc7XG5pbXBvcnQgcmVuZGVyQ2FsbHNpdGVTeW5jIGZyb20gJy4uLy4uL3V0aWxzL3JlbmRlci1jYWxsc2l0ZS1zeW5jJztcbmltcG9ydCB7IFJVTlRJTUVfRVJST1JTIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IGdldFJlbmRlcmVycyBmcm9tICcuLi8uLi91dGlscy9nZXQtcmVuZGVyZXMnO1xuaW1wb3J0IHV0aWwgZnJvbSAndXRpbCc7XG5pbXBvcnQgc2VtdmVyIGZyb20gJ3NlbXZlcic7XG5pbXBvcnQgeyByZW1vdmVQcmV2ZW50TW9kdWxlQ2FjaGluZ1N1ZmZpeCB9IGZyb20gJy4uL3Rlc3QtcnVuL3V0aWxzJztcbmltcG9ydCBSRVBPUlRFUl9NT0RVTEVfUFJFRklYIGZyb20gJy4uLy4uL3JlcG9ydGVyL21vZHVsZS1wcmVmaXgnO1xuXG5jb25zdCBFUlJPUl9TRVBBUkFUT1IgICAgICAgID0gJ1xcblxcbic7XG5jb25zdCBOT19TVEFDS19BVkFJTEFCTEVfTVNHID0gJ05vIHN0YWNrIHRyYWNlIGlzIGF2YWlsYWJsZSBmb3IgdGhpcyBlcnJvcic7XG5jb25zdCBNT0RVTEVfTk9UX0ZPVU5EX0NPREUgID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcldpdGhDYWxsc2l0ZSAoZXJyb3IpIHtcbiAgICBsZXQgZm9ybWF0dGVkTWVzc2FnZSA9ICcnO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FsbHNpdGUgICAgPSBnZXRDYWxsc2l0ZUZvckVycm9yKGVycm9yKTtcbiAgICAgICAgY29uc3Qgc3RhY2tGaWx0ZXIgPSBjcmVhdGVTdGFja0ZpbHRlcigpO1xuXG4gICAgICAgIC8vIE5PVEU6IElmIGZpbGUgZnJvbSBzdGFjayBkb2Vzbid0IGV4aXN0IGFuIGVycm9yIHdpbGwgYmUgcmFpc2VkIGhlcmU6XG4gICAgICAgIGZvcm1hdHRlZE1lc3NhZ2UgPSBjYWxsc2l0ZT8ucmVuZGVyU3luYyh7IHN0YWNrRmlsdGVyIH0pIHx8IE5PX1NUQUNLX0FWQUlMQUJMRV9NU0c7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgZm9ybWF0dGVkTWVzc2FnZSA9IE5PX1NUQUNLX0FWQUlMQUJMRV9NU0c7XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke2Vycm9yLm1lc3NhZ2V9XFxuXFxuJHtmb3JtYXR0ZWRNZXNzYWdlfWA7XG59XG5cbmZ1bmN0aW9uIGlzTW9kdWxlTm90Rm91bmRFcnJvciAoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IuY29kZSAmJiBlcnJvci5jb2RlID09PSBNT0RVTEVfTk9UX0ZPVU5EX0NPREU7XG59XG5cbi8vIE5PVEU6IFRoZSBcIm1lc3NhZ2VcIiBwcm9wZXJ0eSBvZiB0aGUgTW9kdWxlTm90Rm91bmQgZXJyb3IgaGFzIHRoZSBmb2xsb3dpbmcgcGF0dGVybjogPG1lc3NhZ2U+XFxuUmVxdWlyZSBzdGFjazpcXG48bGluZTE+XFxuPGxpbmUyPi5cbi8vIFRoaXMgY29kZSByZW1vdmVzIGxpbmVzIGJlbGxvdyB0aGUgdGFyZ2V0UGF0aC4gSW4gY2FzZSBvZiBcInJlcXVpcmUoJ3Rlc3RjYWZlLXJlcG9ydGVyLTxuYW1lPicpXCIgaXQgcmVtb3ZlcyBhbGwgdGhlIFJlcXVpcmUgc3RhY2suXG5mdW5jdGlvbiBmb3JtYXRNb2R1bGVOb3RGb3VuZEVycm9yUmVxdWlyZVN0YWNrIChtZXNzYWdlLCB0YXJnZXRQYXRoKSB7XG4gICAgY29uc3QgbWVzc2FnZUxpbmVzICAgID0gbWVzc2FnZS5zcGxpdCgnXFxuJyk7XG4gICAgY29uc3QgdGFyZ2V0TGluZUluZGV4ID0gbWVzc2FnZUxpbmVzLmZpbmRJbmRleChsaW5lID0+IGxpbmUuaW5jbHVkZXModGFyZ2V0UGF0aCkpO1xuXG4gICAgaWYgKHRhcmdldExpbmVJbmRleCA9PT0gLTEpXG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuXG4gICAgcmV0dXJuIG1lc3NhZ2VMaW5lcy5zbGljZSgwLCB0YXJnZXRMaW5lSW5kZXggKyAxKS5qb2luKCdcXG4nKTtcbn1cblxuY2xhc3MgUHJvY2Vzc1RlbXBsYXRlSW5zdHJ1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yIChwcm9jZXNzRm4pIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzRm4gPSBwcm9jZXNzRm47XG4gICAgfVxufVxuXG4vLyBFcnJvcnNcbmV4cG9ydCBjbGFzcyBHZW5lcmFsRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgY29kZSAgICAgPSBhcmdzLnNoaWZ0KCk7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gVEVNUExBVEVTW2NvZGVdO1xuXG4gICAgICAgIHN1cGVyKHJlbmRlclRlbXBsYXRlKHRlbXBsYXRlLCAuLi5hcmdzKSk7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IGNvZGUsIGRhdGE6IGFyZ3MgfSk7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEdlbmVyYWxFcnJvcik7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzR2VuZXJhbEVycm9yIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFyZyBpbnN0YW5jZW9mIEdlbmVyYWxFcnJvcjtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBUZXN0Q29tcGlsYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciAob3JpZ2luYWxFcnJvcikge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSAgICAgPSBURU1QTEFURVNbUlVOVElNRV9FUlJPUlMuY2Fubm90UHJlcGFyZVRlc3RzRHVlVG9FcnJvcl07XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHJlbW92ZVByZXZlbnRNb2R1bGVDYWNoaW5nU3VmZml4KG9yaWdpbmFsRXJyb3IudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgc3VwZXIocmVuZGVyVGVtcGxhdGUodGVtcGxhdGUsIGVycm9yTWVzc2FnZSkpO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywge1xuICAgICAgICAgICAgY29kZTogUlVOVElNRV9FUlJPUlMuY2Fubm90UHJlcGFyZVRlc3RzRHVlVG9FcnJvcixcbiAgICAgICAgICAgIGRhdGE6IFtlcnJvck1lc3NhZ2VdLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBOT1RFOiBUaGUgc3RhY2sgaW5jbHVkZXMgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgIHRoaXMuc3RhY2sgPSByZW5kZXJUZW1wbGF0ZSh0ZW1wbGF0ZSwgcmVtb3ZlUHJldmVudE1vZHVsZUNhY2hpbmdTdWZmaXgob3JpZ2luYWxFcnJvci5zdGFjaykpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFQSUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yIChjYWxsc2l0ZSwgY29kZSwgLi4uYXJncykge1xuICAgICAgICBsZXQgdGVtcGxhdGUgPSBURU1QTEFURVNbY29kZV07XG5cbiAgICAgICAgdGVtcGxhdGUgPSBBUElFcnJvci5fcHJlcGFyZVRlbXBsYXRlQW5kQXJnc0lmTmVjZXNzYXJ5KHRlbXBsYXRlLCBhcmdzKTtcblxuICAgICAgICBjb25zdCByYXdNZXNzYWdlID0gcmVuZGVyVGVtcGxhdGUodGVtcGxhdGUsIC4uLmFyZ3MpO1xuXG4gICAgICAgIHN1cGVyKHJlbmRlclRlbXBsYXRlKFRFTVBMQVRFU1tSVU5USU1FX0VSUk9SUy5jYW5ub3RQcmVwYXJlVGVzdHNEdWVUb0Vycm9yXSwgcmF3TWVzc2FnZSkpO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBjb2RlLCBkYXRhOiBhcmdzIH0pO1xuXG4gICAgICAgIC8vIE5PVEU6IGByYXdNZXNzYWdlYCBpcyB1c2VkIGluIGVycm9yIHN1YnN0aXR1dGlvbiBpZiBpdCBvY2N1cnMgaW4gdGVzdCBydW4uXG4gICAgICAgIHRoaXMucmF3TWVzc2FnZSA9IHJhd01lc3NhZ2U7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsc2l0ZSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICB0aGlzLmNhbGxzaXRlID0gY2FsbHNpdGU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuY2FsbHNpdGUgPSBnZXRDYWxsc2l0ZUZvck1ldGhvZChjYWxsc2l0ZSk7XG5cbiAgICAgICAgLy8gTk9URTogUHJvcGVydHkgZ2V0dGVycyBhcmUgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIGNhbGxzaXRlIGNhbiBiZSByZXBsYWNlZCB3aXRoIGV4dGVybmFsIGNvZGUuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRGV2RXhwcmVzcy90ZXN0Y2FmZS9ibG9iL3YxLjAuMC9zcmMvY29tcGlsZXIvdGVzdC1maWxlL2Zvcm1hdHMvcmF3LmpzI0wyMlxuICAgICAgICAvLyBBbHNvIHdlIGNhbid0IHVzZSBhbiBFUzYgZ2V0dGVyIGZvciB0aGUgJ3N0YWNrJyBwcm9wZXJ0eSwgYmVjYXVzZSBpdCB3aWxsIGNyZWF0ZSBhIGdldHRlciBvbiB0aGUgY2xhc3MgcHJvdG90eXBlXG4gICAgICAgIC8vIHRoYXQgY2Fubm90IG92ZXJyaWRlIHRoZSBpbnN0YW5jZSBwcm9wZXJ0eSBjcmVhdGVkIGJ5IHRoZSBFcnJvciBwYXJlbnQgY2xhc3MuXG4gICAgICAgIGNvbnN0IHJlbmRlcmVycyA9IGdldFJlbmRlcmVycyh0aGlzLmNhbGxzaXRlKTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICAnc3RhY2snOiB7XG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiB0aGlzLl9jcmVhdGVTdGFjayhyZW5kZXJlcnMubm9Db2xvciksXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAnY29sb3JlZFN0YWNrJzoge1xuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gdGhpcy5fY3JlYXRlU3RhY2socmVuZGVyZXJzLmRlZmF1bHQpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZVN0YWNrIChyZW5kZXJlcikge1xuICAgICAgICBjb25zdCByZW5kZXJlZENhbGxzaXRlID0gcmVuZGVyQ2FsbHNpdGVTeW5jKHRoaXMuY2FsbHNpdGUsIHtcbiAgICAgICAgICAgIHJlbmRlcmVyOiAgICByZW5kZXJlcixcbiAgICAgICAgICAgIHN0YWNrRmlsdGVyOiBjcmVhdGVTdGFja0ZpbHRlcihFcnJvci5zdGFja1RyYWNlTGltaXQpLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXJlbmRlcmVkQ2FsbHNpdGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuXG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2UgKyBFUlJPUl9TRVBBUkFUT1IgKyByZW5kZXJlZENhbGxzaXRlO1xuICAgIH1cblxuICAgIHN0YXRpYyBfcHJlcGFyZVRlbXBsYXRlQW5kQXJnc0lmTmVjZXNzYXJ5ICh0ZW1wbGF0ZSwgYXJncykge1xuICAgICAgICBjb25zdCBsYXN0QXJnID0gYXJncy5wb3AoKTtcblxuICAgICAgICBpZiAobGFzdEFyZyBpbnN0YW5jZW9mIFByb2Nlc3NUZW1wbGF0ZUluc3RydWN0aW9uKVxuICAgICAgICAgICAgdGVtcGxhdGUgPSBsYXN0QXJnLnByb2Nlc3NGbih0ZW1wbGF0ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGFyZ3MucHVzaChsYXN0QXJnKTtcblxuICAgICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ2xpZW50RnVuY3Rpb25BUElFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciAobWV0aG9kTmFtZSwgaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZSwgY29kZSwgLi4uYXJncykge1xuICAgICAgICBhcmdzLnB1c2gobmV3IFByb2Nlc3NUZW1wbGF0ZUluc3RydWN0aW9uKHRlbXBsYXRlID0+IHRlbXBsYXRlLnJlcGxhY2UoL1xceyNpbnN0YW50aWF0aW9uQ2FsbHNpdGVOYW1lXFx9L2csIGluc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWUpKSk7XG5cbiAgICAgICAgc3VwZXIobWV0aG9kTmFtZSwgY29kZSwgLi4uYXJncyk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ29tcG9zaXRlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IgKGVycm9ycykge1xuICAgICAgICBzdXBlcihlcnJvcnMubWFwKCh7IG1lc3NhZ2UgfSkgPT4gbWVzc2FnZSkuam9pbihFUlJPUl9TRVBBUkFUT1IpKTtcblxuICAgICAgICB0aGlzLnN0YWNrID0gZXJyb3JzLm1hcCgoeyBzdGFjayB9KSA9PiBzdGFjaykuam9pbihFUlJPUl9TRVBBUkFUT1IpO1xuICAgICAgICB0aGlzLmNvZGUgID0gUlVOVElNRV9FUlJPUlMuY29tcG9zaXRlQXJndW1lbnRzRXJyb3I7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVwb3J0ZXJQbHVnaW5FcnJvciBleHRlbmRzIEdlbmVyYWxFcnJvciB7XG4gICAgY29uc3RydWN0b3IgKHsgbmFtZSwgbWV0aG9kLCBvcmlnaW5hbEVycm9yIH0pIHtcbiAgICAgICAgY29uc3QgY29kZSAgICAgICAgICA9IFJVTlRJTUVfRVJST1JTLnVuY2F1Z2h0RXJyb3JJblJlcG9ydGVyO1xuICAgICAgICBjb25zdCBwcmVwYXJlZFN0YWNrID0gUmVwb3J0ZXJQbHVnaW5FcnJvci5fcHJlcGFyZVN0YWNrKG9yaWdpbmFsRXJyb3IpO1xuXG4gICAgICAgIHN1cGVyKGNvZGUsIG1ldGhvZCwgbmFtZSwgcHJlcGFyZWRTdGFjayk7XG4gICAgfVxuXG4gICAgc3RhdGljIF9wcmVwYXJlU3RhY2sgKGVycikge1xuICAgICAgICBpZiAoIWVycj8uc3RhY2spIHtcbiAgICAgICAgICAgIGNvbnN0IGluc3BlY3RlZE9iamVjdCA9IHV0aWwuaW5zcGVjdChlcnIpO1xuXG4gICAgICAgICAgICByZXR1cm4gYE5vIHN0YWNrIHRyYWNlIGlzIGF2YWlsYWJsZSBmb3IgdGhlIHJhaXNlZCBlcnJvci5cXG5FcnJvciBvYmplY3QgaW5zcGVjdGlvbjpcXG4ke2luc3BlY3RlZE9iamVjdH1gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVyci5zdGFjaztcbiAgICB9XG5cbn1cblxuZXhwb3J0IGNsYXNzIFRpbWVvdXRFcnJvciBleHRlbmRzIEdlbmVyYWxFcnJvciB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgICBzdXBlcihSVU5USU1FX0VSUk9SUy50aW1lTGltaXRlZFByb21pc2VUaW1lb3V0RXhwaXJlZCk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQnJvd3NlckNvbm5lY3Rpb25FcnJvciBleHRlbmRzIEdlbmVyYWxFcnJvciB7XG4gICAgY29uc3RydWN0b3IgKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoUlVOVElNRV9FUlJPUlMuYnJvd3NlckNvbm5lY3Rpb25FcnJvciwgLi4uYXJncyk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVxdWVzdFJ1bnRpbWVFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciAobWV0aG9kTmFtZSwgY29kZSwgLi4uYXJncykge1xuICAgICAgICBzdXBlcihtZXRob2ROYW1lLCBjb2RlLCAuLi5hcmdzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTa2lwSnNFcnJvcnNBcmd1bWVudEFwaUVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yIChjb2RlLCAuLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKCdza2lwSnNFcnJvcnMnLCBjb2RlLCAuLi5hcmdzKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBJbXBvcnRFU01JbkNvbW1vbkpTRXJyb3IgZXh0ZW5kcyBHZW5lcmFsRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yIChvcmlnaW5hbEVycm9yLCB0YXJnZXRGaWxlKSB7XG4gICAgICAgIGNvbnN0IGVzTW9kdWxlID0gSW1wb3J0RVNNSW5Db21tb25KU0Vycm9yLl9nZXRFU01vZHVsZShvcmlnaW5hbEVycm9yKTtcblxuICAgICAgICBzdXBlcihSVU5USU1FX0VSUk9SUy5jYW5ub3RJbXBvcnRFU01JbkNvbW1vbnNKUywgZXNNb2R1bGUsIHRhcmdldEZpbGUpO1xuICAgIH1cblxuICAgIHN0YXRpYyBfZ2V0RVNNb2R1bGUgKGVycikge1xuICAgICAgICBjb25zdCByZWdFeHAgICAgICAgPSBzZW12ZXIuZ3RlKHByb2Nlc3MudmVyc2lvbiwgJzE2LjAuMCcpID8gbmV3IFJlZ0V4cCgvRVMgTW9kdWxlIChcXFMqKS8pIDogL0VTIE1vZHVsZTogKFxcUyopLztcbiAgICAgICAgY29uc3QgWywgZXNNb2R1bGVdID0gZXJyLnRvU3RyaW5nKCkubWF0Y2gocmVnRXhwKTtcblxuICAgICAgICByZXR1cm4gZXNNb2R1bGU7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVhZENvbmZpZ0ZpbGVFcnJvciBleHRlbmRzIEdlbmVyYWxFcnJvciB7XG4gICAgY29uc3RydWN0b3IgKGNvZGUsIG9yaWdpbmFsRXJyb3IsIGZpbGVQYXRoLCByZW5kZXJDYWxsc2l0ZSkge1xuICAgICAgICBzdXBlcihjb2RlLCBmaWxlUGF0aCwgUmVhZENvbmZpZ0ZpbGVFcnJvci5fZ2V0Rm9ybWF0dGVkTWVzc2FnZShvcmlnaW5hbEVycm9yLCByZW5kZXJDYWxsc2l0ZSwgZmlsZVBhdGgpKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgX2dldEZvcm1hdHRlZE1lc3NhZ2UgKG9yaWdpbmFsRXJyb3IsIHJlbmRlckNhbGxzaXRlLCBmaWxlUGF0aCkge1xuICAgICAgICBpZiAoIXJlbmRlckNhbGxzaXRlKVxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsRXJyb3IubWVzc2FnZTtcblxuICAgICAgICBpZiAoaXNNb2R1bGVOb3RGb3VuZEVycm9yKG9yaWdpbmFsRXJyb3IpKVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vZHVsZU5vdEZvdW5kRXJyb3JSZXF1aXJlU3RhY2sob3JpZ2luYWxFcnJvci5tZXNzYWdlLCBmaWxlUGF0aCk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdEVycm9yV2l0aENhbGxzaXRlKG9yaWdpbmFsRXJyb3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIExvYWRSZXBvcnRlckVycm9yIGV4dGVuZHMgR2VuZXJhbEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvciAob3JpZ2luYWxFcnJvciwgcmVwb3J0ZXJGdWxsTmFtZSkge1xuICAgICAgICBjb25zdCByZXBvcnRlclNob3J0TmFtZSAgICAgID0gTG9hZFJlcG9ydGVyRXJyb3IuX2Vuc3VyZVNob3J0TmFtZShyZXBvcnRlckZ1bGxOYW1lKTtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkT3JpZ2luYWxFcnJvciA9IExvYWRSZXBvcnRlckVycm9yLl9nZXRGb3JtYXR0ZWRNZXNzYWdlKG9yaWdpbmFsRXJyb3IsIHJlcG9ydGVyRnVsbE5hbWUpO1xuXG4gICAgICAgIHN1cGVyKFJVTlRJTUVfRVJST1JTLmNhbm5vdEZpbmRSZXBvcnRlckZvckFsaWFzLCByZXBvcnRlclNob3J0TmFtZSwgZm9ybWF0dGVkT3JpZ2luYWxFcnJvcik7XG4gICAgfVxuXG4gICAgc3RhdGljIF9lbnN1cmVTaG9ydE5hbWUgKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgJiYgbmFtZS5zdGFydHNXaXRoKFJFUE9SVEVSX01PRFVMRV9QUkVGSVgpKVxuICAgICAgICAgICAgcmV0dXJuIG5hbWUucmVwbGFjZShSRVBPUlRFUl9NT0RVTEVfUFJFRklYLCAnJyk7XG5cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgc3RhdGljIF9nZXRGb3JtYXR0ZWRNZXNzYWdlIChvcmlnaW5hbEVycm9yLCByZXBvcnRlckZ1bGxOYW1lKSB7XG4gICAgICAgIGlmIChpc01vZHVsZU5vdEZvdW5kRXJyb3Iob3JpZ2luYWxFcnJvcikpXG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9kdWxlTm90Rm91bmRFcnJvclJlcXVpcmVTdGFjayhvcmlnaW5hbEVycm9yLm1lc3NhZ2UsIHJlcG9ydGVyRnVsbE5hbWUpO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXRFcnJvcldpdGhDYWxsc2l0ZShvcmlnaW5hbEVycm9yKTtcbiAgICB9XG59XG5cbiJdfQ==