"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeAsyncJsExpression = exports.executeJsExpression = void 0;
const vm_1 = require("vm");
const runtime_1 = require("../../errors/runtime");
const test_run_1 = require("../../errors/test-run");
const execution_context_1 = require("../../api/test-controller/execution-context");
const constants_1 = require("./constants");
const test_run_tracker_1 = __importDefault(require("../../api/test-run-tracker"));
// NOTE: do not beautify this code since offsets for error lines and columns are coded here
function wrapInAsync(expression, testRunId) {
    return `(async function ${test_run_tracker_1.default.getMarkedFnName(testRunId)} () {\n` +
        expression + ';\n' +
        '});';
}
function getErrorLineColumn(err) {
    if (err.isTestCafeError) {
        if (!err.callsite)
            return {};
        if (err.callsite.id)
            return { line: 0, column: 0 };
        const stackFrames = err.callsite.stackFrames || [];
        const frameIndex = err.callsite.callsiteFrameIdx;
        const stackFrame = stackFrames[frameIndex];
        return stackFrame ? {
            line: stackFrame.getLineNumber(),
            column: stackFrame.getColumnNumber(),
        } : {};
    }
    const result = err.stack && err.stack.match(constants_1.ERROR_LINE_COLUMN_REGEXP);
    if (!result)
        return {};
    const line = result[1] ? parseInt(result[1], 10) : void 0;
    const column = result[2] ? parseInt(result[2], 10) : void 0;
    return { line, column };
}
function createErrorFormattingOptions() {
    return {
        filename: constants_1.ERROR_FILENAME,
        lineOffset: constants_1.ERROR_LINE_OFFSET,
    };
}
function getExecutionContext(testController, options = execution_context_1.DEFAULT_CONTEXT_OPTIONS) {
    const context = testController.getExecutionContext();
    // TODO: Find a way to avoid this assignment
    (0, execution_context_1.setContextOptions)(context, options);
    return context;
}
function isRuntimeError(err) {
    return err instanceof runtime_1.GeneralError ||
        err instanceof runtime_1.TestCompilationError ||
        err instanceof runtime_1.APIError ||
        err instanceof runtime_1.CompositeError;
}
function executeJsExpression(expression, testRun, options) {
    const context = testRun.controller ?
        getExecutionContext(testRun.controller, options) :
        (0, execution_context_1.createExecutionContext)(testRun);
    const errorOptions = createErrorFormattingOptions();
    return (0, vm_1.runInContext)(expression, context, errorOptions);
}
exports.executeJsExpression = executeJsExpression;
async function executeAsyncJsExpression(expression, testRun, callsite, onBeforeRaisingError) {
    if (!expression || !expression.length)
        return Promise.resolve();
    const context = getExecutionContext(testRun.controller);
    const errorOptions = createErrorFormattingOptions(expression);
    const wrappedExpression = wrapInAsync(expression, testRun.id);
    try {
        return await (0, vm_1.runInContext)(wrappedExpression, context, errorOptions)();
    }
    catch (err) {
        const { line, column } = getErrorLineColumn(err);
        let resultError = null;
        if (err.isTestCafeError || isRuntimeError(err))
            resultError = new test_run_1.UncaughtTestCafeErrorInCustomScript(err, expression, line, column, callsite);
        else
            resultError = new test_run_1.UncaughtErrorInCustomScript(err, expression, line, column, callsite);
        if (onBeforeRaisingError)
            await onBeforeRaisingError(resultError);
        throw resultError;
    }
}
exports.executeAsyncJsExpression = executeAsyncJsExpression;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdGVzdC1ydW4vZXhlY3V0ZS1qcy1leHByZXNzaW9uL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDJCQUFrQztBQUVsQyxrREFLOEI7QUFFOUIsb0RBQXlHO0FBQ3pHLG1GQUlxRDtBQUVyRCwyQ0FJcUI7QUFFckIsa0ZBQXdEO0FBRXhELDJGQUEyRjtBQUMzRixTQUFTLFdBQVcsQ0FBRSxVQUFVLEVBQUUsU0FBUztJQUN2QyxPQUFPLG1CQUFtQiwwQkFBYyxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUMsU0FBUztRQUNyRSxVQUFVLEdBQUcsS0FBSztRQUNsQixLQUFLLENBQUM7QUFDakIsQ0FBQztBQUVELFNBQVMsa0JBQWtCLENBQUUsR0FBRztJQUM1QixJQUFJLEdBQUcsQ0FBQyxlQUFlLEVBQUU7UUFDckIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRO1lBQ2IsT0FBTyxFQUFFLENBQUM7UUFFZCxJQUFJLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUNmLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQztRQUVsQyxNQUFNLFdBQVcsR0FBRyxHQUFHLENBQUMsUUFBUSxDQUFDLFdBQVcsSUFBSSxFQUFFLENBQUM7UUFDbkQsTUFBTSxVQUFVLEdBQUksR0FBRyxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQztRQUNsRCxNQUFNLFVBQVUsR0FBSSxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFNUMsT0FBTyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ2hCLElBQUksRUFBSSxVQUFVLENBQUMsYUFBYSxFQUFFO1lBQ2xDLE1BQU0sRUFBRSxVQUFVLENBQUMsZUFBZSxFQUFFO1NBQ3ZDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztLQUNWO0lBRUQsTUFBTSxNQUFNLEdBQUcsR0FBRyxD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USxDQUFDLENBQUM7O1lBRS9GLFdBQVcsR0FBRyxJQUFJLHNDQUEyQixDQUFDLEdBQUcsRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztRQUUzRixJQUFJLG9CQUFvQjtZQUNwQixNQUFNLG9CQUFvQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRTVDLE1BQU0sV0FBVyxDQUFDO0tBQ3JCO0FBQ0wsQ0FBQztBQXpCRCw0REF5QkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBydW5JbkNvbnRleHQgfSBmcm9tICd2bSc7XG5cbmltcG9ydCB7XG4gICAgR2VuZXJhbEVycm9yLFxuICAgIFRlc3RDb21waWxhdGlvbkVycm9yLFxuICAgIEFQSUVycm9yLFxuICAgIENvbXBvc2l0ZUVycm9yLFxufSBmcm9tICcuLi8uLi9lcnJvcnMvcnVudGltZSc7XG5cbmltcG9ydCB7IFVuY2F1Z2h0RXJyb3JJbkN1c3RvbVNjcmlwdCwgVW5jYXVnaHRUZXN0Q2FmZUVycm9ySW5DdXN0b21TY3JpcHQgfSBmcm9tICcuLi8uLi9lcnJvcnMvdGVzdC1ydW4nO1xuaW1wb3J0IHtcbiAgICBzZXRDb250ZXh0T3B0aW9ucyxcbiAgICBERUZBVUxUX0NPTlRFWFRfT1BUSU9OUyxcbiAgICBjcmVhdGVFeGVjdXRpb25Db250ZXh0LFxufSBmcm9tICcuLi8uLi9hcGkvdGVzdC1jb250cm9sbGVyL2V4ZWN1dGlvbi1jb250ZXh0JztcblxuaW1wb3J0IHtcbiAgICBFUlJPUl9MSU5FX0NPTFVNTl9SRUdFWFAsXG4gICAgRVJST1JfRklMRU5BTUUsXG4gICAgRVJST1JfTElORV9PRkZTRVQsXG59IGZyb20gJy4vY29uc3RhbnRzJztcblxuaW1wb3J0IFRlc3RSdW5UcmFja2VyIGZyb20gJy4uLy4uL2FwaS90ZXN0LXJ1bi10cmFja2VyJztcblxuLy8gTk9URTogZG8gbm90IGJlYXV0aWZ5IHRoaXMgY29kZSBzaW5jZSBvZmZzZXRzIGZvciBlcnJvciBsaW5lcyBhbmQgY29sdW1ucyBhcmUgY29kZWQgaGVyZVxuZnVuY3Rpb24gd3JhcEluQXN5bmMgKGV4cHJlc3Npb24sIHRlc3RSdW5JZCkge1xuICAgIHJldHVybiBgKGFzeW5jIGZ1bmN0aW9uICR7VGVzdFJ1blRyYWNrZXIuZ2V0TWFya2VkRm5OYW1lKHRlc3RSdW5JZCl9ICgpIHtcXG5gICtcbiAgICAgICAgICAgZXhwcmVzc2lvbiArICc7XFxuJyArXG4gICAgICAgICAgICd9KTsnO1xufVxuXG5mdW5jdGlvbiBnZXRFcnJvckxpbmVDb2x1bW4gKGVycikge1xuICAgIGlmIChlcnIuaXNUZXN0Q2FmZUVycm9yKSB7XG4gICAgICAgIGlmICghZXJyLmNhbGxzaXRlKVxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuXG4gICAgICAgIGlmIChlcnIuY2FsbHNpdGUuaWQpXG4gICAgICAgICAgICByZXR1cm4geyBsaW5lOiAwLCBjb2x1bW46IDAgfTtcblxuICAgICAgICBjb25zdCBzdGFja0ZyYW1lcyA9IGVyci5jYWxsc2l0ZS5zdGFja0ZyYW1lcyB8fCBbXTtcbiAgICAgICAgY29uc3QgZnJhbWVJbmRleCAgPSBlcnIuY2FsbHNpdGUuY2FsbHNpdGVGcmFtZUlkeDtcbiAgICAgICAgY29uc3Qgc3RhY2tGcmFtZSAgPSBzdGFja0ZyYW1lc1tmcmFtZUluZGV4XTtcblxuICAgICAgICByZXR1cm4gc3RhY2tGcmFtZSA/IHtcbiAgICAgICAgICAgIGxpbmU6ICAgc3RhY2tGcmFtZS5nZXRMaW5lTnVtYmVyKCksXG4gICAgICAgICAgICBjb2x1bW46IHN0YWNrRnJhbWUuZ2V0Q29sdW1uTnVtYmVyKCksXG4gICAgICAgIH0gOiB7fTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBlcnIuc3RhY2sgJiYgZXJyLnN0YWNrLm1hdGNoKEVSUk9SX0xJTkVfQ09MVU1OX1JFR0VYUCk7XG5cbiAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgcmV0dXJuIHt9O1xuXG4gICAgY29uc3QgbGluZSAgID0gcmVzdWx0WzFdID8gcGFyc2VJbnQocmVzdWx0WzFdLCAxMCkgOiB2b2lkIDA7XG4gICAgY29uc3QgY29sdW1uID0gcmVzdWx0WzJdID8gcGFyc2VJbnQocmVzdWx0WzJdLCAxMCkgOiB2b2lkIDA7XG5cbiAgICByZXR1cm4geyBsaW5lLCBjb2x1bW4gfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXJyb3JGb3JtYXR0aW5nT3B0aW9ucyAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZW5hbWU6ICAgRVJST1JfRklMRU5BTUUsXG4gICAgICAgIGxpbmVPZmZzZXQ6IEVSUk9SX0xJTkVfT0ZGU0VULFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldEV4ZWN1dGlvbkNvbnRleHQgKHRlc3RDb250cm9sbGVyLCBvcHRpb25zID0gREVGQVVMVF9DT05URVhUX09QVElPTlMpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGVzdENvbnRyb2xsZXIuZ2V0RXhlY3V0aW9uQ29udGV4dCgpO1xuXG4gICAgLy8gVE9ETzogRmluZCBhIHdheSB0byBhdm9pZCB0aGlzIGFzc2lnbm1lbnRcbiAgICBzZXRDb250ZXh0T3B0aW9ucyhjb250ZXh0LCBvcHRpb25zKTtcblxuICAgIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBpc1J1bnRpbWVFcnJvciAoZXJyKSB7XG4gICAgcmV0dXJuIGVyciBpbnN0YW5jZW9mIEdlbmVyYWxFcnJvciB8fFxuICAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBUZXN0Q29tcGlsYXRpb25FcnJvciB8fFxuICAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBBUElFcnJvciB8fFxuICAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBDb21wb3NpdGVFcnJvcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVKc0V4cHJlc3Npb24gKGV4cHJlc3Npb24sIHRlc3RSdW4sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb250ZXh0ID0gdGVzdFJ1bi5jb250cm9sbGVyID9cbiAgICAgICAgZ2V0RXhlY3V0aW9uQ29udGV4dCh0ZXN0UnVuLmNvbnRyb2xsZXIsIG9wdGlvbnMpIDpcbiAgICAgICAgY3JlYXRlRXhlY3V0aW9uQ29udGV4dCh0ZXN0UnVuKTtcblxuICAgIGNvbnN0IGVycm9yT3B0aW9ucyA9IGNyZWF0ZUVycm9yRm9ybWF0dGluZ09wdGlvbnMoKTtcblxuICAgIHJldHVybiBydW5JbkNvbnRleHQoZXhwcmVzc2lvbiwgY29udGV4dCwgZXJyb3JPcHRpb25zKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVBc3luY0pzRXhwcmVzc2lvbiAoZXhwcmVzc2lvbiwgdGVzdFJ1biwgY2FsbHNpdGUsIG9uQmVmb3JlUmFpc2luZ0Vycm9yKSB7XG4gICAgaWYgKCFleHByZXNzaW9uIHx8ICFleHByZXNzaW9uLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXG4gICAgY29uc3QgY29udGV4dCAgICAgICAgICAgPSBnZXRFeGVjdXRpb25Db250ZXh0KHRlc3RSdW4uY29udHJvbGxlcik7XG4gICAgY29uc3QgZXJyb3JPcHRpb25zICAgICAgPSBjcmVhdGVFcnJvckZvcm1hdHRpbmdPcHRpb25zKGV4cHJlc3Npb24pO1xuICAgIGNvbnN0IHdyYXBwZWRFeHByZXNzaW9uID0gd3JhcEluQXN5bmMoZXhwcmVzc2lvbiwgdGVzdFJ1bi5pZCk7XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgcnVuSW5Db250ZXh0KHdyYXBwZWRFeHByZXNzaW9uLCBjb250ZXh0LCBlcnJvck9wdGlvbnMpKCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgeyBsaW5lLCBjb2x1bW4gfSA9IGdldEVycm9yTGluZUNvbHVtbihlcnIpO1xuICAgICAgICBsZXQgcmVzdWx0RXJyb3IgICAgICAgID0gbnVsbDtcblxuICAgICAgICBpZiAoZXJyLmlzVGVzdENhZmVFcnJvciB8fCBpc1J1bnRpbWVFcnJvcihlcnIpKVxuICAgICAgICAgICAgcmVzdWx0RXJyb3IgPSBuZXcgVW5jYXVnaHRUZXN0Q2FmZUVycm9ySW5DdXN0b21TY3JpcHQoZXJyLCBleHByZXNzaW9uLCBsaW5lLCBjb2x1bW4sIGNhbGxzaXRlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVzdWx0RXJyb3IgPSBuZXcgVW5jYXVnaHRFcnJvckluQ3VzdG9tU2NyaXB0KGVyciwgZXhwcmVzc2lvbiwgbGluZSwgY29sdW1uLCBjYWxsc2l0ZSk7XG5cbiAgICAgICAgaWYgKG9uQmVmb3JlUmFpc2luZ0Vycm9yKVxuICAgICAgICAgICAgYXdhaXQgb25CZWZvcmVSYWlzaW5nRXJyb3IocmVzdWx0RXJyb3IpO1xuXG4gICAgICAgIHRocm93IHJlc3VsdEVycm9yO1xuICAgIH1cbn1cbiJdfQ==