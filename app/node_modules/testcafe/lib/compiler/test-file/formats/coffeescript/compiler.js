"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const coffeescript_1 = __importDefault(require("coffeescript"));
const load_libs_1 = __importDefault(require("../../../babel/load-libs"));
const compiler_js_1 = __importDefault(require("../es-next/compiler.js"));
const extensions_1 = __importDefault(require("../extensions"));
const FIXTURE_RE = /(^|;|\s+)fixture\s*(\.|\(|'|")/;
const TEST_RE = /(^|;|\s+)test\s*/;
class CoffeeScriptTestFileCompiler extends compiler_js_1.default {
    _hasTests(code) {
        return FIXTURE_RE.test(code) && TEST_RE.test(code);
    }
    _compileCode(code, filename) {
        if (this.cache[filename])
            return this.cache[filename];
        const transpiled = coffeescript_1.default.compile(code, {
            filename,
            bare: true,
            sourceMap: true,
            inlineMap: true,
            header: false,
        });
        const { babel } = (0, load_libs_1.default)();
        const babelOptions = compiler_js_1.default.getBabelOptions(filename, code, this);
        const compiled = babel.transform(transpiled.js, babelOptions);
        this.cache[filename] = compiled.code;
        return compiled.code;
    }
    _getRequireCompilers() {
        return { [extensions_1.default.coffee]: (code, filename) => this._compileCode(code, filename) };
    }
    getSupportedExtension() {
        return extensions_1.default.coffee;
    }
}
exports.default = CoffeeScriptTestFileCompiler;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvY29tcGlsZXIvdGVzdC1maWxlL2Zvcm1hdHMvY29mZmVlc2NyaXB0L2NvbXBpbGVyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsZ0VBQXdDO0FBQ3hDLHlFQUFxRDtBQUNyRCx5RUFBNEQ7QUFDNUQsK0RBQXVDO0FBRXZDLE1BQU0sVUFBVSxHQUFHLGdDQUFnQyxDQUFDO0FBQ3BELE1BQU0sT0FBTyxHQUFNLGtCQUFrQixDQUFDO0FBRXRDLE1BQXFCLDRCQUE2QixTQUFRLHFCQUFzQjtJQUM1RSxTQUFTLENBQUUsSUFBSTtRQUNYLE9BQU8sVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3ZELENBQUM7SUFFRCxZQUFZLENBQUUsSUFBSSxFQUFFLFFBQVE7UUFDeEIsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQztZQUNwQixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFaEMsTUFBTSxVQUFVLEdBQUcsc0JBQVksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFO1lBQzFDLFFBQVE7WUFDUixJQUFJLEVBQU8sSUFBSTtZQUNmLFNBQVMsRUFBRSxJQUFJO1lBQ2YsU0FBUyxFQUFFLElBQUk7WUFDZixNQUFNLEVBQUssS0FBSztTQUNuQixDQUFDLENBQUM7UUFFSCxNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQU0sSUFBQSxtQkFBYSxHQUFFLENBQUM7UUFDckMsTUFBTSxZQUFZLEdBQUcscUJBQXNCLENBQUMsZUFBZSxDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDbEYsTUFBTSxRQUFRLEdBQU8sS0FBSyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsRUFBRSxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBRWxFLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQztRQUVyQyxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUM7SUFDekIsQ0FBQztJQUVELG9CQUFvQjtRQUNoQixPQUFPLEVBQUUsQ0FBQyxvQkFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLEVBQUUsQ0FBQztJQUMxRixDQUFDO0lBRUQscUJBQXFCO1FBQ2pCLE9BQU8sb0JBQVUsQ0FBQyxNQUFNLENBQUM7SUFDN0IsQ0FBQztDQUNKO0FBakNELCtDQWlDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb2ZmZWVTY3JpcHQgZnJvbSAnY29mZmVlc2NyaXB0JztcbmltcG9ydCBsb2FkQmFiZWxMaWJzIGZyb20gJy4uLy4uLy4uL2JhYmVsL2xvYWQtbGlicyc7XG5pbXBvcnQgRVNOZXh0VGVzdEZpbGVDb21waWxlciBmcm9tICcuLi9lcy1uZXh0L2NvbXBpbGVyLmpzJztcbmltcG9ydCBFeHRlbnNpb25zIGZyb20gJy4uL2V4dGVuc2lvbnMnO1xuXG5jb25zdCBGSVhUVVJFX1JFID0gLyhefDt8XFxzKylmaXh0dXJlXFxzKihcXC58XFwofCd8XCIpLztcbmNvbnN0IFRFU1RfUkUgICAgPSAvKF58O3xcXHMrKXRlc3RcXHMqLztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29mZmVlU2NyaXB0VGVzdEZpbGVDb21waWxlciBleHRlbmRzIEVTTmV4dFRlc3RGaWxlQ29tcGlsZXIge1xuICAgIF9oYXNUZXN0cyAoY29kZSkge1xuICAgICAgICByZXR1cm4gRklYVFVSRV9SRS50ZXN0KGNvZGUpICYmIFRFU1RfUkUudGVzdChjb2RlKTtcbiAgICB9XG5cbiAgICBfY29tcGlsZUNvZGUgKGNvZGUsIGZpbGVuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmNhY2hlW2ZpbGVuYW1lXSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlW2ZpbGVuYW1lXTtcblxuICAgICAgICBjb25zdCB0cmFuc3BpbGVkID0gQ29mZmVlU2NyaXB0LmNvbXBpbGUoY29kZSwge1xuICAgICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgICBiYXJlOiAgICAgIHRydWUsXG4gICAgICAgICAgICBzb3VyY2VNYXA6IHRydWUsXG4gICAgICAgICAgICBpbmxpbmVNYXA6IHRydWUsXG4gICAgICAgICAgICBoZWFkZXI6ICAgIGZhbHNlLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB7IGJhYmVsIH0gICAgPSBsb2FkQmFiZWxMaWJzKCk7XG4gICAgICAgIGNvbnN0IGJhYmVsT3B0aW9ucyA9IEVTTmV4dFRlc3RGaWxlQ29tcGlsZXIuZ2V0QmFiZWxPcHRpb25zKGZpbGVuYW1lLCBjb2RlLCB0aGlzKTtcbiAgICAgICAgY29uc3QgY29tcGlsZWQgICAgID0gYmFiZWwudHJhbnNmb3JtKHRyYW5zcGlsZWQuanMsIGJhYmVsT3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5jYWNoZVtmaWxlbmFtZV0gPSBjb21waWxlZC5jb2RlO1xuXG4gICAgICAgIHJldHVybiBjb21waWxlZC5jb2RlO1xuICAgIH1cblxuICAgIF9nZXRSZXF1aXJlQ29tcGlsZXJzICgpIHtcbiAgICAgICAgcmV0dXJuIHsgW0V4dGVuc2lvbnMuY29mZmVlXTogKGNvZGUsIGZpbGVuYW1lKSA9PiB0aGlzLl9jb21waWxlQ29kZShjb2RlLCBmaWxlbmFtZSkgfTtcbiAgICB9XG5cbiAgICBnZXRTdXBwb3J0ZWRFeHRlbnNpb24gKCkge1xuICAgICAgICByZXR1cm4gRXh0ZW5zaW9ucy5jb2ZmZWU7XG4gICAgfVxufVxuIl19