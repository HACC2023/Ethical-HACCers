'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _require = require('eslint-plugin-react/lib/util/variable');

let findVariable = _require.findVariable,
    variablesInScope = _require.variablesInScope;

let htmlTags = require('html-tags');
let svgTags = require('svg-tags');

let standardTags = new Set(htmlTags.concat(svgTags));

/**
 * Check the factory function is imported if JSX is being used
 */

let factoryInScopeRule = context => {
  let config = context.options[0] || {};
  let name = config.pragma || 'JSX';
  return {
    JSXOpeningElement: function JSXOpeningElement(node) {
      var variables = variablesInScope(context);
      if (findVariable(variables, name)) return;
      context.report({
        message: '\'' + name + '\' must be in scope when using JSX syntax',
        node: node
      });
    }
  };
};

factoryInScopeRule.schema = [{
  type: 'object',
  properties: {
    pragma: { type: 'string' }
  },
  additionalProperties: false
}];

/**
 * Prevent the JSX factory function from being marked as unused
 * if it will be in the compiled source
 */

let usesFactoryRule = context => {
  let config = context.options[0] || {};
  let id = config.pragma || 'JSX';
  return {
    JSXElement: function JSXElement() {
      context.markVariableAsUsed(id);
    }
  };
};

usesFactoryRule.schema = factoryInScopeRule.schema;

/**
 * Prevent variables used in JSX to be marked as unused
 */

let markUsedRule = context => {
  return {
    JSXOpeningElement: function JSXOpeningElement(node) {
      var name = node.name;
      if (name.type == 'JSXMemberExpression') name = name.object;
      if (name.type == 'JSXNamespacedName') name = name.namespace;
      context.markVariableAsUsed(name.name);
    },
    JSXAttribute: function JSXAttribute(attr) {
      if (attr.value == null) context.markVariableAsUsed(attr.name.name);
    }
  };
};

/**
 * Disallow undeclared variables in JSX
 */

let noUndefRule = context => {
  let config = context.options[0] || {};
  let ignoreAttributes = !!config.ignoreAttributes;
  let ignored = config.varsIgnorePattern && new RegExp(config.varsIgnorePattern);
  let isIgnored = ignored ? name => ignored.test(name) : () => false;

  return {
    JSXOpeningElement: function JSXOpeningElement(node) {
      var name = node.name;
      if (name.type == 'JSXMemberExpression') name = name.object;
      if (name.type == 'JSXNamespacedName') name = name.namespace;
      let variables = variablesInScope(context);

      if (!ignoreAttributes) {
        node.attributes.forEach(attr => {
          if (attr.type == 'JSXSpreadAttribute') return;
          if (attr.value == null && !isIgnored(attr.name.name)) checkDefined(context, variables, attr.name);
        });
      }
      if (!standardTags.has(name.name) && !isIgnored(name.name)) checkDefined(context, variables, name);
    }
  };
};

let checkDefined = (context, variables, node) => {
  if (findVariable(variables, node.name)) return;
  context.report({
    message: '\'' + node.name + '\' is not defined',
    node: node
  });
};

let rules = {
  'uses-factory': usesFactoryRule,
  'factory-in-scope': factoryInScopeRule,
  'mark-used-vars': markUsedRule,
  'no-undef': noUndefRule

  // enable all by default
};let rulesConfig = {
  'uses-factory': 1,
  'factory-in-scope': 1,
  'mark-used-vars': 1,
  'no-undef': 1
};

exports.rules = rules;
exports.rulesConfig = rulesConfig;

