import { cleanNulls, expandKey, isBasicObject, makeKeyGeneric, reportNulls } from './util.js';
export type MongoDoc = Record<string, unknown>;
export interface GetFlatObjectOptions {
    /**
     * Pass `true` to keep entire arrays
     */
    keepArrays?: boolean;
}
interface DocToModifierOptions {
    /**
     * Pass `true` to $set entire arrays. Otherwise the modifier will $set individual array items.
     */
    keepArrays?: boolean;
    /**
     * Pass `true` to keep empty strings in the $set. Otherwise $unset them.
     */
    keepEmptyStrings?: boolean;
}
interface PositionInfo {
    key: string;
    operator: string | null;
    position: string;
}
export interface KeyInfo {
    operator: string | null;
    value: any;
}
export default class MongoObject {
    private _affectedKeys;
    private _arrayItemPositions;
    private readonly _blackboxKeys;
    private _genericAffectedKeys;
    private readonly _obj;
    private _objectPositions;
    private _parentPositions;
    private _positionsByGenericKey;
    private _positionsInsideArrays;
    private _positionsThatCreateGenericKey;
    constructor(obj: MongoDoc, blackboxKeys?: string[]);
    _reParseObj(): void;
    /**
     * @param func
     * @param [options]
     * @param [options.endPointsOnly=true] - Only call function for endpoints and not for nodes that contain other nodes
     * @returns
     *
     * Runs a function for each endpoint node in the object tree, including all items in every array.
     * The function arguments are
     * (1) the value at this node
     * (2) a string representing the node position
     * (3) the representation of what would be changed in mongo, using mongo dot notation
     * (4) the generic equivalent of argument 3, with '$' instead of numeric pieces
     */
    forEachNode(func: () => void, { endPointsOnly }?: {
        endPointsOnly?: boolean | undefined;
    }): void;
    getValueForPosition(position: string): any;
    /**
     * @param position
     * @param value
     */
    setValueForPosition(position: string, value: any): void;
    removeValueForPosition(position: string): void;
    getKeyForPosition(position: string): string | null | undefined;
    getGenericKeyForPosition(position: string): string | null | undefined;
    /**
     * @param key Non-generic key
     * @returns The value and operator of the requested non-generic key.
     *   Example: {value: 1, operator: "$pull"}
     */
    getInfoForKey(key: string): KeyInfo | undefined;
    /**
     * @method MongoObject.getPositionForKey
     * @param {String} key - Non-generic key
     * @returns The position string for the place in the object that
     *   affects the requested non-generic key.
     *   Example: 'foo[bar][0]'
     */
    getPositionForKey(key: string): string | undefined;
    /**
     * @param genericKey Generic key
     * @returns An array of position strings for the places in the object that
     *   affect the requested generic key.
     *   Example: ['foo[bar][0]']
     */
    getPositionsForGenericKey(genericKey: string): string[];
    /**
     * @param genericKey Generic key
     * @returns An array of position info for the places in the object that
     *   affect the requested generic key.
     */
    getPositionsInfoForGenericKey(genericKey: string): PositionInfo[];
    getPositionsThatCreateGenericKey(genericKey: string): PositionInfo[];
    /**
     * @deprecated Use getInfoForKey
     * @param {String} key - Non-generic key
     * @returns The value of the requested non-generic key
     */
    getValueForKey(key: string): any;
    /**
     * Adds `key` with value `val` under operator `op` to the source object.
     *
     * @param key Key to set
     * @param val Value to give this key
     * @param op Operator under which to set it, or `null` for a non-modifier object
     * @returns
     */
    addKey(key: string, val: any, op: string | null): void;
    /**
     * Removes anything that affects any of the generic keys in the list
     */
    removeGenericKeys(keys: string[]): void;
    /**
     * Removes anything that affects the requested generic key
     */
    removeGenericKey(key: string): void;
    /**
     * Removes anything that affects the requested non-generic key
     */
    removeKey(key: string): void;
    /**
     * Removes anything that affects any of the non-generic keys in the list
     */
    removeKeys(keys: string[]): void;
    /**
     * Passes all affected keys to a test function, which
     * should return false to remove whatever is affecting that key
     */
    filterGenericKeys(test: (genericKey: string) => boolean): void;
    /**
     * Sets the value for every place in the object that affects
     * the requested non-generic key
     */
    setValueForKey(key: string, val: any): void;
    /**
     * Sets the value for every place in the object that affects
     * the requested generic key
     */
    setValueForGenericKey(key: string, val: any): void;
    removeArrayItems(): void;
    /**
     * Get the source object, potentially modified by other method calls on this
     * MongoObject instance.
     */
    getObject(): MongoDoc;
    /**
     * Gets a flat object based on the MongoObject instance.
     * In a flat object, the key is the name of the non-generic affectedKey,
     * with mongo dot notation if necessary, and the value is the value for
     * that key.
     *
     * With `keepArrays: true`, we don't flatten within arrays. Currently
     * MongoDB does not see a key such as `a.0.b` and automatically assume
     * an array. Instead it would create an object with key '0' if there
     * wasn't already an array saved as the value of `a`, which is rarely
     * if ever what we actually want. To avoid this confusion, we
     * set entire arrays.
     */
    getFlatObject({ keepArrays }?: GetFlatObjectOptions): Record<string, any>;
    /**
     * @method MongoObject.affectsKey
     * @param key Key to test
     * @returns True if the non-generic key is affected by this object
     */
    affectsKey(key: string): boolean;
    /**
     * @method MongoObject.affectsGenericKey
     * @param key Key to test
     * @returns True if the generic key is affected by this object
     */
    affectsGenericKey(key: string): boolean;
    /**
     * @method MongoObject.affectsGenericKeyImplicit
     * @param key Key to test
     * @returns Like affectsGenericKey, but will return true if a child key is affected
     */
    affectsGenericKeyImplicit(key: string): boolean;
    private static readonly _keyToPosition;
    static cleanNulls: typeof cleanNulls;
    static expandKey: typeof expandKey;
    static isBasicObject: typeof isBasicObject;
    static makeKeyGeneric: typeof makeKeyGeneric;
    static reportNulls: typeof reportNulls;
    /**
     * This is different from MongoObject.prototype.getKeyForPosition in that
     * this method does not depend on the requested position actually being
     * present in any particular MongoObject.
     *
     * @method MongoObject._positionToKey
     * @param position
     * @returns The key that this position in an object would affect.
     */
    static _positionToKey(position: string): string | null | undefined;
    /**
     * @method MongoObject.docToModifier
     * @public
     * @param doc - An object to be converted into a MongoDB modifier
     * @param [options] Options
     * @returns A MongoDB modifier.
     *
     * Converts an object into a modifier by flattening it, putting keys with
     * null, undefined, and empty string values into `modifier.$unset`, and
     * putting the rest of the keys into `modifier.$set`.
     */
    static docToModifier(doc: any, { keepArrays, keepEmptyStrings }?: DocToModifierOptions): any;
    static objAffectsKey(obj: any, key: string): boolean;
    /**
     * @param genericKey Generic key
     * @return Array of other generic keys that would be created by this generic key
     */
    static objectsThatGenericKeyWillCreate(genericKey: string): string[];
    /**
     * Takes a flat object and returns an expanded version of it.
     */
    static expandObj(doc: Record<string, any>): Record<string, any>;
}
export {};
