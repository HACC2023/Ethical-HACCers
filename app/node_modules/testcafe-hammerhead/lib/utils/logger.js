"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const err_to_string_1 = __importDefault(require("./err-to-string"));
function getIncorrectErrorTypeMessage(err) {
    const errType = typeof err;
    return `The "${(0, err_to_string_1.default)(err)}" error of the "${errType}" type was passed. Make sure that service message handlers throw errors of the Error type.`;
}
debug_1.default.formatters.i = (ctx) => {
    const stringifiedInfoArr = [];
    const contentInfo = ctx.contentInfo;
    if (ctx.isPage)
        stringifiedInfoArr.push('isPage');
    if (ctx.isIframe)
        stringifiedInfoArr.push('isIframe');
    if (ctx.isAjax)
        stringifiedInfoArr.push('isAjax');
    if (ctx.isWebSocket)
        stringifiedInfoArr.push('isWebSocket');
    if (contentInfo.isCSS)
        stringifiedInfoArr.push('isCSS');
    if (contentInfo.isScript)
        stringifiedInfoArr.push('isScript');
    if (contentInfo.isManifest)
        stringifiedInfoArr.push('isManifest');
    if (contentInfo.isFileDownload)
        stringifiedInfoArr.push('isFileDownload');
    if (ctx.contentInfo.isNotModified)
        stringifiedInfoArr.push('isNotModified');
    if (contentInfo.isRedirect)
        stringifiedInfoArr.push('isRedirect');
    if (contentInfo.isIframeWithImageSrc)
        stringifiedInfoArr.push('isIframeWithImageSrc');
    if (contentInfo.charset)
        stringifiedInfoArr.push('charset: ' + contentInfo.charset.get());
    stringifiedInfoArr.push('encoding: ' + contentInfo.encoding);
    stringifiedInfoArr.push('requireProcessing: ' + contentInfo.requireProcessing);
    return `{ ${stringifiedInfoArr.join(', ')} }`;
};
const testcafe = (0, debug_1.default)('testcafe');
const hammerhead = testcafe.extend('hammerhead');
const proxyLogger = hammerhead.extend('proxy');
const destinationLogger = hammerhead.extend('destination');
const http2DestinationLogger = destinationLogger.extend('http2');
const cachedDestinationLogger = destinationLogger.extend('cached');
const destinationSocketLogger = destinationLogger.extend('socket');
const serviceMsgLogger = hammerhead.extend('service-message');
const router = proxyLogger.extend('router');
const serviceSocketLogger = hammerhead.extend('service-socket');
const requestHooksLogger = hammerhead.extend('request-hooks');
const proxy = {
    onRequest: (ctx) => {
        proxyLogger('request %O', {
            requestId: ctx.requestId,
            method: ctx.req.method,
            url: ctx.req.url,
            headers: ctx.req.headers,
        });
    },
    onResponse: (ctx, headers) => {
        proxyLogger('response %O', {
            requestId: ctx.requestId,
            statusCode: ctx.destRes.statusCode,
            headers,
        });
    },
    onSendResponseBody: (ctx) => {
        proxyLogger('send response body %O', {
            requestId: ctx.requestId,
            body: ctx.destResBody.toString(),
        });
    },
    onRequestError: (ctx) => {
        proxyLogger('error: request to proxy cannot be dispatched %s, responding 404', ctx.requestId);
    },
    onWebSocketResponseError: (ctx, e) => {
        proxyLogger('error %s %o', ctx.requestId, e);
    },
    onCORSFailed: (ctx) => {
        proxyLogger('CORS check failed %s', ctx.requestId);
    },
    onContentInfoBuilt: (ctx) => {
        proxyLogger('resource content info %s %i', ctx.requestId, ctx);
    },
    onMockResponseError: (rule, e) => {
        proxyLogger('error %s %s', rule, e);
    },
};
const serviceMsg = {
    onMessage: (msg, result) => {
        serviceMsgLogger('%j, result %j', msg, result);
    },
    onError: (msg, err) => {
        const isError = err instanceof Error;
        const errMsg = isError ? err : getIncorrectErrorTypeMessage(err);
        serviceMsgLogger('%j, error %o', msg, errMsg);
    },
};
const serviceSocket = {
    onConnection: (ws) => {
        serviceSocketLogger('Service socket connected to %j', ws.url);
    },
    onError: (err) => {
        const isError = err instanceof Error;
        const errMsg = isError ? err : getIncorrectErrorTypeMessage(err);
        serviceSocketLogger('Service socket error %j', errMsg);
    },
};
const destination = {
    onMockedRequest: (ctx) => {
        destinationLogger('mocked %O', {
            requestId: ctx.requestId,
            statusCode: ctx.mock.statusCode,
            headers: ctx.mock.headers,
        });
    },
    onRequest: (opts) => {
        destinationLogger('%O', {
            requestId: opts.requestId,
            method: opts.method,
            url: opts.url,
            headers: opts.headers,
        });
    },
    onCachedRequest: (opts, hitCount) => {
        cachedDestinationLogger('%O', {
            requestId: opts.requestId,
            method: opts.method,
            url: opts.url,
            headers: opts.headers,
            hitCount,
        });
    },
    onHttp2Stream: (requestId, headers) => {
        http2DestinationLogger('stream %s %j', requestId, headers);
    },
    onHttp2Unsupported: (requestId, origin) => {
        http2DestinationLogger('server does not support http2 %s %s', requestId, origin);
    },
    onHttp2SessionCreated: (requestId, origin, cacheSize, cacheTotalSize) => {
        http2DestinationLogger('session created %s %s (cache size %d of %d)', requestId, origin, cacheSize, cacheTotalSize);
    },
    onHttp2SessionClosed: (requestId, origin, cacheSize, cacheTotalSize) => {
        http2DestinationLogger('session closed %s %s (cache size %d of %d)', requestId, origin, cacheSize, cacheTotalSize);
    },
    onHttp2Error: (requestId, origin, err) => {
        http2DestinationLogger('error %s %s %o', requestId, origin, err);
    },
    onHttp2SessionTimeout: (origin, timeout) => {
        http2DestinationLogger('session is unused more than %d min and will be closed %s', timeout / 60000, origin);
    },
    onUpgradeRequest: (opts, res) => {
        destinationLogger('upgrade %O', {
            requestId: opts.requestId,
            statusCode: res.statusCode,
            headers: res.headers,
        });
    },
    onResponse: (opts, res) => {
        destinationLogger('response %O', {
            requestId: opts.requestId,
            statusCode: res.statusCode,
            headers: res.headers,
        });
    },
    onProxyAuthenticationError: (opts) => {
        destinationLogger('error: Cannot authorize to proxy %s', opts.requestId);
    },
    onResendWithCredentials: (opts) => {
        destinationLogger('request resent with credentials %s', opts.requestId);
    },
    onFileRead: (ctx) => {
        destinationLogger('Read file %s %s', ctx.requestId, ctx.reqOpts.url);
    },
    onFileReadError: (ctx, err) => {
        destinationLogger('File read error %s %o', ctx.requestId, err);
    },
    onTimeoutError: (opts, timeout) => {
        destinationLogger('request timeout %s (%d ms)', opts.requestId, timeout);
    },
    onError: (opts, err) => {
        destinationLogger('error %s %o', opts.requestId, err);
    },
};
const destinationSocket = {
    enabled: destinationSocketLogger.enabled,
    onFirstChunk: (opts, data) => {
        destinationSocketLogger('socket first chunk of data %O', {
            requestId: opts.requestId,
            length: data.length,
            data: JSON.stringify(data.toString()),
        });
    },
    onError: (opts, err) => {
        destinationSocketLogger('socket error %s %o', opts.requestId, err);
    },
};
const requestHooks = {
    onMockedResponse: (init) => {
        requestHooksLogger('mocked response %O', init);
    },
};
exports.default = {
    proxy,
    destination,
    destinationSocket,
    serviceMsg,
    router,
    serviceSocket,
    requestHooks,
};module.exports = exports.default;

