"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const request_is_match_rule_1 = __importDefault(require("../request-is-match-rule"));
const names_1 = __importDefault(require("./names"));
class RequestHookEventProvider {
    constructor() {
        this.requestEventListeners = new Map();
        this.requestHookEventData = this._initRequestHookEventData();
    }
    _initRequestHookEventData() {
        return {
            mocks: new Map(),
            configureResponse: new Map(),
        };
    }
    hasRequestEventListeners() {
        return !!this.requestEventListeners.size;
    }
    async addRequestEventListeners(rule, listeners, errorHandler) {
        const listenersData = {
            listeners,
            errorHandler,
            rule,
        };
        this.requestEventListeners.set(rule.id, listenersData);
    }
    async removeRequestEventListeners(rule) {
        this.requestEventListeners.delete(rule.id);
    }
    clearRequestEventListeners() {
        this.requestEventListeners.clear();
    }
    async getRequestFilterRules(requestInfo) {
        const rulesArray = Array.from(this.requestEventListeners.values())
            .map(listenerData => listenerData.rule);
        const matchedRules = await Promise.all(rulesArray.map(async (rule) => {
            if (await (0, request_is_match_rule_1.default)(rule, requestInfo))
                return rule;
            return void 0;
        }));
        return matchedRules.filter(rule => !!rule);
    }
    async setMock(responseEventId, mock) {
        this.requestHookEventData.mocks.set(responseEventId, mock);
    }
    getMock(responseEventId) {
        return this.requestHookEventData.mocks.get(responseEventId);
    }
    async _patchOnConfigureResponseEvent(eventName, event) {
        // At present, this way is used only in the TestCafe's 'compiler service' run mode.
        // Later, we need to remove the old event-based mechanism and use this one.
        if (eventName !== names_1.default.onConfigureResponse)
            return;
        const targetEvent = event;
        const eventData = this.requestHookEventData.configureResponse.get(targetEvent.id);
        if (!eventData)
            return;
        targetEvent.opts = eventData.opts;
        await Promise.all(eventData.setHeaders.map(({ name, value }) => {
            return targetEvent.setHeader(name, value);
        }));
        await Promise.all(eventData.removedHeaders.map(header => {
            return targetEvent.removeHeader(header);
        }));
    }
    async callRequestEventCallback(eventName, rule, eventData) {
        const requestEventListenersData = this.requestEventListeners.get(rule.id);
        if (!requestEventListenersData)
            return;
        const { listeners, errorHandler } = requestEventListenersData;
        const targetRequestEventCallback = listeners[eventName];
        if (typeof targetRequestEventCallback !== 'function')
            return;
        try {
            await targetRequestEventCallback(eventData);
            await this._patchOnConfigureResponseEvent(eventName, eventData);
        }
        catch (e) {
            if (typeof errorHandler !== 'function')
                return;
            const event = {
                error: e,
                methodName: eventName,
            };
            errorHandler(event);
        }
    }
    async callRequestHookErrorHandler(rule, e) {
        const requestEventListenersData = this.requestEventListeners.get(rule.id);
        if (!requestEventListenersData)
            return;
        const { errorHandler } = requestEventListenersData;
        const event = {
            error: e,
            methodName: names_1.default.onResponse,
        };
        errorHandler(event);
    }
}
exports.default = RequestHookEventProvider;module.exports = exports.default;

