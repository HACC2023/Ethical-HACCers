import { __rest } from "tslib";
import clone from 'lodash/clone';
import cloneDeep from 'lodash/cloneDeep';
import get from 'lodash/get';
import isEqual from 'lodash/isEqual';
import noop from 'lodash/noop';
import setWith from 'lodash/setWith';
import React, { Component } from 'react';
import { changedKeys } from './changedKeys';
import { context } from './context';
import { randomIds } from './randomIds';
export class Form extends Component {
    constructor() {
        super(...arguments);
        this.state = {
            changed: false,
            changedMap: Object.create(null),
            error: null,
            model: this.props.model,
            resetCount: 0,
            submitted: false,
            submitting: false,
            validate: false,
            validating: false,
            validator: this.props.schema.getValidator(this.props.validator),
        };
        this.delayId = undefined;
        this.mounted = false;
        this.randomId = randomIds(this.props.id);
        this.getAutoField = () => {
            return () => null;
        };
        this.getErrorsField = () => {
            return () => null;
        };
        this.getSubmitField = () => {
            return () => null;
        };
        this.getNativeFormProps = () => {
            /* eslint-disable @typescript-eslint/no-unused-vars */
            const _a = this.props, { autosave, autosaveDelay, disabled, error, errorsField: ErrorsField = this.getErrorsField(), label, model, modelTransform, onChange, onChangeModel, onSubmit, onValidate, placeholder, readOnly, schema, showInlineError, submitField: SubmitField = this.getSubmitField(), validate, validator } = _a, props = __rest(_a, ["autosave", "autosaveDelay", "disabled", "error", "errorsField", "label", "model", "modelTransform", "onChange", "onChangeModel", "onSubmit", "onValidate", "placeholder", "readOnly", "schema", "showInlineError", "submitField", "validate", "validator"]);
            /* eslint-enable @typescript-eslint/no-unused-vars */
            // @ts-expect-error `props` is too generic.
            props.key = `reset-${this.state.resetCount}`;
            // @ts-expect-error `props` is too generic.
            props.onSubmit = this.onSubmit;
            if (!props.children) {
                const AutoField = this.getAutoField();
                // @ts-expect-error `props` is too generic.
                props.children = schema
                    .getSubfields()
                    .map(key => React.createElement(AutoField, { key: key, name: key }))
                    .concat([
                    React.createElement(ErrorsField, { key: "$ErrorsField" }),
                    React.createElement(SubmitField, { key: "$SubmitField" }),
                ]);
            }
            return props;
        };
        this.onChange = (key, value) => {
            if (shouldRevalidate(this.props.validate, this.state.validate)) {
                this.onValidate(key, value);
            }
            // Do not set `changed` before componentDidMount
            if (this.mounted) {
                const keys = changedKeys(key, value, get(this.getModel(), key));
                if (keys.length !== 0) {
                    this.setState(state => 
                    // If all are already marked, we can skip the update completely.
                    state.changed && keys.every(key => !!get(state.changedMap, key))
                        ? null
                        : {
                            changed: true,
                            changedMap: keys.reduce((changedMap, key) => setWith(changedMap, key, {}, clone), clone(state.changedMap)),
                        });
                }
            }
            if (this.props.onChange) {
                this.props.onChange(key, value);
            }
            // Do not call `onSubmit` before componentDidMount
            if (this.mounted && this.props.autosave) {
                if (this.delayId) {
                    clearTimeout(this.delayId);
                }
                // Delay autosave by `autosaveDelay` milliseconds...
                this.delayId = setTimeout(() => {
                    // ...and wait for all scheduled `setState`s to commit. This is required
                    // for AutoForm to validate correct model, waiting in `onChange`.
                    this.setState(() => null, () => {
                        this.onSubmit();
                    });
                }, this.props.autosaveDelay);
            }
            this.setState(
            // @ts-expect-error Should `Model` extend `object`?
            state => ({ model: setWith(clone(state.model), key, value, clone) }), () => {
                if (this.props.onChangeModel) {
                    this.props.onChangeModel(this.getModel());
                }
            });
        };
        this.onReset = () => {
            this.setState(this.__reset);
        };
        this.onSubmit = (event) => {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            this.setState({ submitted: true, validate: true });
            const result = this.onValidate().then(error => {
                if (error !== null) {
                    return Promise.reject(error);
                }
                this.setState(state => (state.submitted ? null : { submitted: true }));
                const result = this.props.onSubmit(this.getModel('submit'));
                if (!(result instanceof Promise)) {
                    return Promise.resolve();
                }
                this.setState({ submitting: true });
                result.then(() => {
                    this.setState({ submitting: false });
                }, error => {
                    this.setState({ error, submitting: false });
                });
                return result;
            });
            result.catch(noop);
            return result;
        };
        this.onValidate = (key, value) => {
            let model = this.getModel();
            if (model && key) {
                // @ts-expect-error Should `Model` extend `object`?
                model = setWith(clone(model), key, cloneDeep(value), clone);
            }
            return this.onValidateModel(model);
        };
        this.onValidateModel = (originalModel) => {
            const model = this.getModel('validate', originalModel);
            return this.__then(this.state.validator(model), (error = null) => this.__then(this.props.onValidate(model, error), (error = null) => {
                var _a;
                // Do not copy the error from props to the state.
                error = this.props.error === error ? null : error;
                // If the whole operation was synchronous and resulted in the same
                // error, we can skip the re-render.
                this.setState(state => state.error === error && !state.validating
                    ? null
                    : { error, validating: false });
                // A predefined error takes precedence over the validation one.
                return Promise.resolve((_a = this.props.error) !== null && _a !== void 0 ? _a : error);
            }));
        };
        this.__reset = (state, props) => ({
            changed: false,
            changedMap: Object.create(null),
            error: null,
            model: props.model,
            resetCount: state.resetCount + 1,
            submitted: false,
            submitting: false,
            validate: false,
            validating: false,
        });
        // Using `then` allows using the same code for both synchronous and
        // asynchronous cases. We could use `await` here, but it would make all
        // calls asynchronous, unnecessary delaying synchronous validation.
        this.__then = makeThen(() => {
            this.setState({ validating: true });
        });
    }
    componentDidMount() {
        this.mounted = true;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    componentDidUpdate(prevProps, prevState, snapshot) {
        const { model, schema, validate, validator } = this.props;
        if (!isEqual(model, prevProps.model)) {
            this.setState({ model });
        }
        if (schema !== prevProps.schema || validator !== prevProps.validator) {
            this.setState({ validator: schema.getValidator(validator) }, () => {
                if (shouldRevalidate(validate, this.state.validate)) {
                    this.onValidate();
                }
            });
        }
        else if (!isEqual(model, prevProps.model) &&
            shouldRevalidate(validate, this.state.validate)) {
            this.onValidateModel(model);
        }
    }
    componentWillUnmount() {
        this.mounted = false;
        if (this.delayId) {
            clearTimeout(this.delayId);
        }
        // There are at least 4 places where we'd need to check, whether or not we
        // actually perform `setState` after the component gets unmounted. Instead,
        // we override it to hide the React warning. Also because React no longer
        // will raise it in the newer versions.
        // https://github.com/facebook/react/pull/22114
        // https://github.com/vazco/uniforms/issues/1152
        this.setState = () => { };
    }
    getContext() {
        var _a;
        const { onChange, onSubmit, randomId, props, state } = this;
        return {
            changed: state.changed,
            changedMap: state.changedMap,
            error: (_a = props.error) !== null && _a !== void 0 ? _a : state.error,
            // @ts-expect-error This should be limited to a few methods so the users won't do "crazy stuff", e.g., call `setState`.
            formRef: this,
            model: this.getModel('form'),
            name: [],
            onChange,
            onSubmit,
            randomId,
            schema: props.schema,
            state: {
                disabled: props.disabled,
                label: props.label,
                placeholder: props.placeholder,
                readOnly: props.readOnly,
                showInlineError: props.showInlineError,
            },
            submitted: state.submitted,
            submitting: state.submitting,
            validating: state.validating,
        };
    }
    getModel(mode, model = this.state.model) {
        return mode !== undefined && this.props.modelTransform
            ? this.props.modelTransform(mode, model)
            : model;
    }
    render() {
        return (React.createElement(context.Provider, { value: this.getContext() },
            React.createElement("form", Object.assign({}, this.getNativeFormProps()))));
    }
}
Form.defaultProps = {
    autosave: false,
    autosaveDelay: 0,
    disabled: false,
    error: null,
    label: true,
    model: Object.create(null),
    noValidate: true,
    placeholder: false,
    onChange() { },
    onChangeModel() { },
    onSubmit() { },
    onValidate(model, error) {
        return error;
    },
    readOnly: false,
    showInlineError: false,
    validate: 'onChangeAfterSubmit',
};
function makeThen(callIfAsync) {
    function then(value, fn) {
        if (value instanceof Promise) {
            callIfAsync();
            return value.then(fn);
        }
        return fn(value);
    }
    return then;
}
function shouldRevalidate(inProps, inState) {
    return (inProps === 'onChange' || (inProps === 'onChangeAfterSubmit' && inState));
}
